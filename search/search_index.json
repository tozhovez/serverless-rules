{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Serverless Rules are a compilation of rules to validate infrastructure-as-code template against recommended practices. This currently provides a module for cfn-lint and a plugin for tflint . You can use those rules to get quick feedback on recommended practices while building a serverless application, as part of an automated code review process, or as guardrails before deploying to production. Public preview This project is currently in public preview to get feedback from the serverless community. APIs, tools, and rules might change between the beginning of public preview and version 1. Current modules and plugins \u00b6 The cfn-lint module supports checking CloudFormation and Serverless Application Model (SAM) templates. It also supports templates defined with the AWS Cloud Development Kit (CDK) and the Serverless Framework by synthesizing to CloudFormation. The tflint plugin supports checking Terraform configuration files. If you would like native support for other frameworks, please consider adding a \ud83d\udc4d reaction to the corresponding comment in this GitHub issue . Usage \u00b6 To learn how to use Serverless Rules, see the detailed usage guide for each plugin: With cfn-lint With tflint Frequently asked questions \u00b6 Can I ignore some of the rules in this project? \u00b6 Serverless Rules is a set of recommended practices. We recommend you to keep Error-level rules enabled. Non-error rules, for example Lambda Tracing , contain detailed scenarios on when it\u2019s safe to ignore them. When needed, you can ignore any specific rule that doesn\u2019t match your environment. How is this different from cfn-lint or tflint-ruleset-aws ? \u00b6 cfn-lint and tflint main goals are to find possible errors in templates and configuration files before you try to deploy resources to AWS. By comparison, Serverless Rules goes one step further by providing prescriptive guidance based on the AWS Well-Architected pillars . For example, you can define AWS Lambda functions without tracing enabled, which is valid for both CloudFormation and Terraform. This project adds a rule on Lambda tracing as a recommended practice for Operational Excellence. Why use cfn-lint instead of cfn-guard or cfn_nag ? \u00b6 cfn-guard provides developers with a simplified language to define polices and validate JSON- or YAML- formatted documents. You can use that tool to create your own rules that match your compliance needs or internal recommended practices. cfn_nag provides a set of default rules with a strong focus on security. You can extend it in ruby to create custom rules. By comparison, cfn-lint provides a set of default rules focused on validating templates against the CloudFormation resource specification and you can create your own rule with Python modules. For Serverless Rules , using a programming language like Python or Ruby gives more flexibility when defining complex rules integrating multiple resources, such as checking if a Lambda function has a log group with retention configured .","title":"Homepage"},{"location":"#current-modules-and-plugins","text":"The cfn-lint module supports checking CloudFormation and Serverless Application Model (SAM) templates. It also supports templates defined with the AWS Cloud Development Kit (CDK) and the Serverless Framework by synthesizing to CloudFormation. The tflint plugin supports checking Terraform configuration files. If you would like native support for other frameworks, please consider adding a \ud83d\udc4d reaction to the corresponding comment in this GitHub issue .","title":"Current modules and plugins"},{"location":"#usage","text":"To learn how to use Serverless Rules, see the detailed usage guide for each plugin: With cfn-lint With tflint","title":"Usage"},{"location":"#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"#can-i-ignore-some-of-the-rules-in-this-project","text":"Serverless Rules is a set of recommended practices. We recommend you to keep Error-level rules enabled. Non-error rules, for example Lambda Tracing , contain detailed scenarios on when it\u2019s safe to ignore them. When needed, you can ignore any specific rule that doesn\u2019t match your environment.","title":"Can I ignore some of the rules in this project?"},{"location":"#how-is-this-different-from-cfn-lint-or-tflint-ruleset-aws","text":"cfn-lint and tflint main goals are to find possible errors in templates and configuration files before you try to deploy resources to AWS. By comparison, Serverless Rules goes one step further by providing prescriptive guidance based on the AWS Well-Architected pillars . For example, you can define AWS Lambda functions without tracing enabled, which is valid for both CloudFormation and Terraform. This project adds a rule on Lambda tracing as a recommended practice for Operational Excellence.","title":"How is this different from cfn-lint or tflint-ruleset-aws?"},{"location":"#why-use-cfn-lint-instead-of-cfn-guard-or-cfn_nag","text":"cfn-guard provides developers with a simplified language to define polices and validate JSON- or YAML- formatted documents. You can use that tool to create your own rules that match your compliance needs or internal recommended practices. cfn_nag provides a set of default rules with a strong focus on security. You can extend it in ruby to create custom rules. By comparison, cfn-lint provides a set of default rules focused on validating templates against the CloudFormation resource specification and you can create your own rule with Python modules. For Serverless Rules , using a programming language like Python or Ruby gives more flexibility when defining complex rules integrating multiple resources, such as checking if a Lambda function has a log group with retention configured .","title":"Why use cfn-lint instead of cfn-guard or cfn_nag?"},{"location":"cfn-lint/","text":"cfn-lint module \u00b6 Installation \u00b6 Serverless Rules for cfn-lint is available through the cfn-lint-serverless Python module in PyPi. You can use pip to install the module: 1 pip install cfn-lint cfn-lint-serverless Usage \u00b6 You can now instruct cfn-lint to use Serverless Rules installed previous via --append-rules , or -a for short: 1 cfn-lint my_template.yaml -a cfn_lint_serverless.rules You can also try with a Serverless Application Model (SAM) example provided in this repository. In the root folder of the repository, you can run: 1 cfn-lint examples/sam/template.yaml -a cfn_lint_serverless.rules Sample outputs \u00b6 If the template fulfills the requirements for all rules, cfn-lint will return an empty output. Otherwise, cfn-lint will output recommendations. Matching template 1 2 $ cfn-lint template.yaml -a cfn_lint_serverless.rules $ With recommendations 1 2 3 4 5 6 7 8 9 10 $ cfn-lint template.yaml -a cfn_lint_serverless.rules ES4000 EventBridge rule ConsumerFunctionTrigger should have a DeadLetterConfig.Arn property for all its Targets. template.yaml:5:1 WS1000 Lambda function ConsumerFunction should have TracingConfig.Mode set to 'Active' . template.yaml:7:3 WS1004 Lambda function ConsumerFunction does not have a corresponding log group with a Retention property template.yaml:7:3 $ Ignoring rules \u00b6 Serverless Rules is a set of recommended practices. We recommend you to keep Error-level rules enabled. Non-error rules, for example Lambda Tracing , contain detailed scenarios on when it\u2019s safe to ignore them. When needed, you can ignore any specific rule that doesn\u2019t match your environment. Rules in cfn-lint can be disabled either through the --ignore-checks / -i command line argument, or with the .cfnlintrc configuration file in the current working directory. See the cfn-lint documentation for more information. Command line 1 2 # Disable rule WS1000 cfn-lint my_template.yaml -a cfn_lint_serverless.rules -i WS1000 .cfnlintrc 1 2 3 ignore_checks : # Disable rule WS1000 - WS1000 Other frameworks \u00b6 You can use the cfn-lint module with all frameworks that synthesize to a CloudFormation template, such as the AWS Cloud Development Kit (CDK) and the Serverless Framework . CDK \u00b6 With the AWS CDK , you define your cloud resources using a familiar programming language such as TypeScript, Python, Java, C#/.Net, or Go. It will then use CloudFormation to provision those resources in your AWS environments. Under the hood, CDK will generate a CloudFormation template before initiating a deployment on AWS. You can use the cdk synth command to generate that template manually. You can then run cfn-lint for inspecting that template. 1 2 cdk synth > template.yaml cfn-lint template.yaml -a cfn_lint_serverless.rules You can also try with a CDK example provided in this repository. In the root folder of the repository, you can run: 1 2 3 cd examples/cdk/ cdk synth > template.yaml cfn-lint template.yaml -a cfn_lint_serverless.rules Serverless Framework \u00b6 The Serverless Framework is a specialized framework for Serverless applications that uses CloudFormation under the hood when deploying resources to AWS. You can manually create a package using the sls package command, which will generate the CloudFormation templates. With the --package option, you can specify in which folder it will store your package. In that folder, you can find the CloudFormation templates as JSON files starting with cloudformation-template- . You can then run cfn-lint for inspecting those templates. 1 2 sls package --package output/ cfn-lint output/cloudformation-template-*.json -a cfn_lint_serverless.rules Continuous integration \u00b6 You can use Serverless Rules and cfn-lint with your continuous integration tool to automatically check CloudFormation templates with rules from this project. For example, you can validate on pull requests, merge to your main branch, or before deploying to production. If there are any issues with your template, cfn-lint will return a non-zero error code. You can find more information about cfn-lint return codes in its documentation . AWS CodeBuild \u00b6 Assuming that you are storing your template as template.yaml at the root of your repository, you can create a buildspec file such as this one: Sample buildspec 1 2 3 4 5 6 7 8 9 10 11 12 13 14 version : 0.2 phases : install : runtime-versions : python : \"3.8\" commands : # Install cfn-lint-serverless - pip install cfn-lint cfn-lint-serverless pre_build : commands : # TODO: replace here with your template name if you are not # using 'template.yaml'. - cfn-lint template.yaml -a cfn_lint_serverless.rules With JUnit report 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 version : 0.2 phases : install : runtime-versions : python : \"3.8\" commands : # Install cfn-lint-serverless - pip install cfn-lint cfn-lint-serverless pre_build : commands : # TODO: replace here with your template name if you are not # using 'template.yaml'. - cfn-lint template.yaml -a cfn_lint_serverless.rules -f junit --output-file cfn_lint_report.xml reports : cfn-lint : files : - cfn_lint_report.xml If you want to run cfn-lint with other frameworks, see how you can generate CloudFormation templates in the Other frameworks section of this documentation. GitHub Actions \u00b6 Assuming that your template is stored as template.yaml at the root of your repository and that you are using main as your target branch for pull requests, you can create a GitHub actions workflow file such as this one: Sample workflow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 name : cfn-lint-serverless on : pull_request : branches : # TODO: replace this if you are not using 'main' as your target # branch for pull requests. - main jobs : cfn-lint-serverless : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - name : Set up Python 3.8 uses : actions/setup-python@v2 with : python-version : \"3.8\" - name : Install cfn-lint-serverless # Install cfn-lint-serverless run : pip install cfn-lint cfn-lint-serverless - name : Lint CloudFormation template # TODO: replace here with your template name if you are not # using 'template.yaml'. run : cfn-lint template.yaml -a cfn_lint_serverless.rules With JUnit report 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name : cfn-lint-serverless on : pull_request : branches : # TODO: replace this if you are not using 'main' as your target # branch for pull requests. - main jobs : cfn-lint-serverless : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - name : Set up Python 3.8 uses : actions/setup-python@v2 with : python-version : \"3.8\" - name : Install cfn-lint-serverless # Install cfn-lint-serverless run : pip install cfn-lint cfn-lint-serverless - name : Lint CloudFormation template # TODO: replace here with your template name if you are not # using 'template.yaml'. run : cfn-lint template.yaml -a cfn_lint_serverless.rules -f junit --output-file cfn_lint_report.xml # Annotate PR based on cfn-lint's findings - name : Publish test report uses : mikepenz/action-junit-report@v2 # Only run this step on failure if : ${{ failure() }} with : report_paths : cfn_lint_report.xml If you want to run cfn-lint with other frameworks, see how you can generate CloudFormation templates in the Other frameworks section of this documentation. GitLab \u00b6 Assuming that your template is stored as template.yaml at the root of your repository, you can create a .gitlab-ci.yml file such as this one: Sample file 1 2 3 4 5 6 7 8 9 10 cfn-lint-serverless : image : python:latest only : - merge_requests script : # Install cfn-lint-serverless - pip install cfn-lint cfn-lint-serverless # TODO: replace here with your template name if you are not # using 'template.yaml'. - cfn-lint template.yaml -a cfn_lint_serverless.rules With JUnit report 1 2 3 4 5 6 7 8 9 10 11 12 13 14 cfn-lint-serverless : image : python:latest only : - merge_requests script : # Install cfn-lint-serverless - pip install cfn-lint cfn-lint-serverless # TODO: replace here with your template name if you are not # using 'template.yaml'. - cfn-lint template.yaml -a cfn_lint_serverless.rules -f junit --output-file cfn_lint_report.xml artifacts : when : always reports : junit : cfn_lint_report.xml If you want to run cfn-lint with other frameworks, see how you can generate CloudFormation templates in the Other frameworks section of this documentation. Existing stacks \u00b6 If you want to check if a stack already deployed to AWS matches the recommended practices from Serverless Rules, you can download the CloudFormation template and run cfn-lint locally. Existing stack 1 2 3 4 5 6 7 8 9 STACK_NAME = \"your-cloudformation-stack-name\" # Retrieve the template from AWS CloudFormation aws cloudformation get-template \\ --stack-name $STACK_NAME \\ --query 'TemplateBody' > template.json # Run cfn-lint cfn-lint template.json -a cfn_lint_serverless.rules IDE integration \u00b6 Visual Studio Code \u00b6 For Visual Studio Code, you can add the CloudFormation Linter extension, which will automatically run cfn-lint on your CloudFormation templates. In the extension's settings.json file, you can add additional rules like so: Extension settings 1 2 3 4 5 6 7 { // ... o t her se tt i n gs omi tte d \"cfnLint.appendRules\" : [ \"cfn_lint_serverless.rules\" ] }","title":"With cfn-lint"},{"location":"cfn-lint/#cfn-lint-module","text":"","title":"cfn-lint module"},{"location":"cfn-lint/#installation","text":"Serverless Rules for cfn-lint is available through the cfn-lint-serverless Python module in PyPi. You can use pip to install the module: 1 pip install cfn-lint cfn-lint-serverless","title":"Installation"},{"location":"cfn-lint/#usage","text":"You can now instruct cfn-lint to use Serverless Rules installed previous via --append-rules , or -a for short: 1 cfn-lint my_template.yaml -a cfn_lint_serverless.rules You can also try with a Serverless Application Model (SAM) example provided in this repository. In the root folder of the repository, you can run: 1 cfn-lint examples/sam/template.yaml -a cfn_lint_serverless.rules","title":"Usage"},{"location":"cfn-lint/#sample-outputs","text":"If the template fulfills the requirements for all rules, cfn-lint will return an empty output. Otherwise, cfn-lint will output recommendations. Matching template 1 2 $ cfn-lint template.yaml -a cfn_lint_serverless.rules $ With recommendations 1 2 3 4 5 6 7 8 9 10 $ cfn-lint template.yaml -a cfn_lint_serverless.rules ES4000 EventBridge rule ConsumerFunctionTrigger should have a DeadLetterConfig.Arn property for all its Targets. template.yaml:5:1 WS1000 Lambda function ConsumerFunction should have TracingConfig.Mode set to 'Active' . template.yaml:7:3 WS1004 Lambda function ConsumerFunction does not have a corresponding log group with a Retention property template.yaml:7:3 $","title":"Sample outputs"},{"location":"cfn-lint/#ignoring-rules","text":"Serverless Rules is a set of recommended practices. We recommend you to keep Error-level rules enabled. Non-error rules, for example Lambda Tracing , contain detailed scenarios on when it\u2019s safe to ignore them. When needed, you can ignore any specific rule that doesn\u2019t match your environment. Rules in cfn-lint can be disabled either through the --ignore-checks / -i command line argument, or with the .cfnlintrc configuration file in the current working directory. See the cfn-lint documentation for more information. Command line 1 2 # Disable rule WS1000 cfn-lint my_template.yaml -a cfn_lint_serverless.rules -i WS1000 .cfnlintrc 1 2 3 ignore_checks : # Disable rule WS1000 - WS1000","title":"Ignoring rules"},{"location":"cfn-lint/#other-frameworks","text":"You can use the cfn-lint module with all frameworks that synthesize to a CloudFormation template, such as the AWS Cloud Development Kit (CDK) and the Serverless Framework .","title":"Other frameworks"},{"location":"cfn-lint/#cdk","text":"With the AWS CDK , you define your cloud resources using a familiar programming language such as TypeScript, Python, Java, C#/.Net, or Go. It will then use CloudFormation to provision those resources in your AWS environments. Under the hood, CDK will generate a CloudFormation template before initiating a deployment on AWS. You can use the cdk synth command to generate that template manually. You can then run cfn-lint for inspecting that template. 1 2 cdk synth > template.yaml cfn-lint template.yaml -a cfn_lint_serverless.rules You can also try with a CDK example provided in this repository. In the root folder of the repository, you can run: 1 2 3 cd examples/cdk/ cdk synth > template.yaml cfn-lint template.yaml -a cfn_lint_serverless.rules","title":"CDK"},{"location":"cfn-lint/#serverless-framework","text":"The Serverless Framework is a specialized framework for Serverless applications that uses CloudFormation under the hood when deploying resources to AWS. You can manually create a package using the sls package command, which will generate the CloudFormation templates. With the --package option, you can specify in which folder it will store your package. In that folder, you can find the CloudFormation templates as JSON files starting with cloudformation-template- . You can then run cfn-lint for inspecting those templates. 1 2 sls package --package output/ cfn-lint output/cloudformation-template-*.json -a cfn_lint_serverless.rules","title":"Serverless Framework"},{"location":"cfn-lint/#continuous-integration","text":"You can use Serverless Rules and cfn-lint with your continuous integration tool to automatically check CloudFormation templates with rules from this project. For example, you can validate on pull requests, merge to your main branch, or before deploying to production. If there are any issues with your template, cfn-lint will return a non-zero error code. You can find more information about cfn-lint return codes in its documentation .","title":"Continuous integration"},{"location":"cfn-lint/#aws-codebuild","text":"Assuming that you are storing your template as template.yaml at the root of your repository, you can create a buildspec file such as this one: Sample buildspec 1 2 3 4 5 6 7 8 9 10 11 12 13 14 version : 0.2 phases : install : runtime-versions : python : \"3.8\" commands : # Install cfn-lint-serverless - pip install cfn-lint cfn-lint-serverless pre_build : commands : # TODO: replace here with your template name if you are not # using 'template.yaml'. - cfn-lint template.yaml -a cfn_lint_serverless.rules With JUnit report 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 version : 0.2 phases : install : runtime-versions : python : \"3.8\" commands : # Install cfn-lint-serverless - pip install cfn-lint cfn-lint-serverless pre_build : commands : # TODO: replace here with your template name if you are not # using 'template.yaml'. - cfn-lint template.yaml -a cfn_lint_serverless.rules -f junit --output-file cfn_lint_report.xml reports : cfn-lint : files : - cfn_lint_report.xml If you want to run cfn-lint with other frameworks, see how you can generate CloudFormation templates in the Other frameworks section of this documentation.","title":"AWS CodeBuild"},{"location":"cfn-lint/#github-actions","text":"Assuming that your template is stored as template.yaml at the root of your repository and that you are using main as your target branch for pull requests, you can create a GitHub actions workflow file such as this one: Sample workflow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 name : cfn-lint-serverless on : pull_request : branches : # TODO: replace this if you are not using 'main' as your target # branch for pull requests. - main jobs : cfn-lint-serverless : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - name : Set up Python 3.8 uses : actions/setup-python@v2 with : python-version : \"3.8\" - name : Install cfn-lint-serverless # Install cfn-lint-serverless run : pip install cfn-lint cfn-lint-serverless - name : Lint CloudFormation template # TODO: replace here with your template name if you are not # using 'template.yaml'. run : cfn-lint template.yaml -a cfn_lint_serverless.rules With JUnit report 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name : cfn-lint-serverless on : pull_request : branches : # TODO: replace this if you are not using 'main' as your target # branch for pull requests. - main jobs : cfn-lint-serverless : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - name : Set up Python 3.8 uses : actions/setup-python@v2 with : python-version : \"3.8\" - name : Install cfn-lint-serverless # Install cfn-lint-serverless run : pip install cfn-lint cfn-lint-serverless - name : Lint CloudFormation template # TODO: replace here with your template name if you are not # using 'template.yaml'. run : cfn-lint template.yaml -a cfn_lint_serverless.rules -f junit --output-file cfn_lint_report.xml # Annotate PR based on cfn-lint's findings - name : Publish test report uses : mikepenz/action-junit-report@v2 # Only run this step on failure if : ${{ failure() }} with : report_paths : cfn_lint_report.xml If you want to run cfn-lint with other frameworks, see how you can generate CloudFormation templates in the Other frameworks section of this documentation.","title":"GitHub Actions"},{"location":"cfn-lint/#gitlab","text":"Assuming that your template is stored as template.yaml at the root of your repository, you can create a .gitlab-ci.yml file such as this one: Sample file 1 2 3 4 5 6 7 8 9 10 cfn-lint-serverless : image : python:latest only : - merge_requests script : # Install cfn-lint-serverless - pip install cfn-lint cfn-lint-serverless # TODO: replace here with your template name if you are not # using 'template.yaml'. - cfn-lint template.yaml -a cfn_lint_serverless.rules With JUnit report 1 2 3 4 5 6 7 8 9 10 11 12 13 14 cfn-lint-serverless : image : python:latest only : - merge_requests script : # Install cfn-lint-serverless - pip install cfn-lint cfn-lint-serverless # TODO: replace here with your template name if you are not # using 'template.yaml'. - cfn-lint template.yaml -a cfn_lint_serverless.rules -f junit --output-file cfn_lint_report.xml artifacts : when : always reports : junit : cfn_lint_report.xml If you want to run cfn-lint with other frameworks, see how you can generate CloudFormation templates in the Other frameworks section of this documentation.","title":"GitLab"},{"location":"cfn-lint/#existing-stacks","text":"If you want to check if a stack already deployed to AWS matches the recommended practices from Serverless Rules, you can download the CloudFormation template and run cfn-lint locally. Existing stack 1 2 3 4 5 6 7 8 9 STACK_NAME = \"your-cloudformation-stack-name\" # Retrieve the template from AWS CloudFormation aws cloudformation get-template \\ --stack-name $STACK_NAME \\ --query 'TemplateBody' > template.json # Run cfn-lint cfn-lint template.json -a cfn_lint_serverless.rules","title":"Existing stacks"},{"location":"cfn-lint/#ide-integration","text":"","title":"IDE integration"},{"location":"cfn-lint/#visual-studio-code","text":"For Visual Studio Code, you can add the CloudFormation Linter extension, which will automatically run cfn-lint on your CloudFormation templates. In the extension's settings.json file, you can add additional rules like so: Extension settings 1 2 3 4 5 6 7 { // ... o t her se tt i n gs omi tte d \"cfnLint.appendRules\" : [ \"cfn_lint_serverless.rules\" ] }","title":"Visual Studio Code"},{"location":"tflint/","text":"tflint plugin \u00b6 Installation \u00b6 This plugin depends on tflint . If you use tflint version 0.29 or newer, you can leverage the tflint --init command to automatically install the plugin. Otherwise, you will need to download the tflint-ruleset-aws-serverless binary corresponding to your system from the releases page . You can enable the Serverless Rules plugin by adding a plugin section in the .tflint.hcl file in your project: 1 2 3 4 5 plugin \"aws-serverless\" { enabled = true version = \"0.1.8\" source = \"github.com/awslabs/serverless-rules\" } Usage \u00b6 You can now run the tflint command, which will automatically use the Serverless Rules plugin: 1 tflint You can also try with a Terraform example provided in this repository. From the root folder of the repository, you can run: 1 2 cd examples/tflint/ tflint Sample outputs \u00b6 If the Terraform configuration files fulfill the requirements for all the rules, tflint will return an empty output. Otherwise, tflint will output recommendations. Matching template 1 2 $ tflint $ With recommendations 1 2 3 4 5 6 7 8 $ tflint 1 issue ( s ) found: Warning: \"tracing_config\" is not present. ( aws_lambda_function_tracing_rule ) on main.tf line 20 : $ Ignoring rules \u00b6 Serverless Rules is a set of recommended practices. We recommend you to keep Error-level rules enabled. Non-error rules, for example Lambda Tracing , contain detailed scenarios on when it\u2019s safe to ignore them. When needed, you can ignore any specific rule that doesn\u2019t match your environment. Rules in tflint can be disabled either through the --disable-rule command-line argument or with the .tflint.hcl configuration file in the current working directory. See the tflint user guide for more information. Command line 1 2 # Disable the aws_lambda_function_tracing_rule rule tflint --disable-rule aws_lambda_function_tracing_rule .tflint.hcl 1 2 3 4 5 6 7 8 9 10 plugin \"aws-serverless\" { enabled = true version = \"0.1.6\" source = \"github.com/awslabs/serverless-rules\" } # Disable the aws_lambda_function_tracing_rule rule rule \"aws_lambda_function_tracing_rule\" { enabled = false } Continuous integration \u00b6 You can use Serverless Rules and tflint with your continuous integration tool to automatically check CloudFormation templates with rules from this project. For example, you can validate on pull requests, merge to your main branch, or before deploying to production. If there are any issues with your template, tflint will return a non-zero error code. AWS CodeBuild \u00b6 Assuming that you are storing your terraform configuration files and a .tflint.hcl file at the root of your repository, you can create a buildspec file such as this one. Important Make sure that you include the aws-serverless plugin into your .tflint.hcl configuration file, otherwise tflint will not install this ruleset. See Installation for more information. Sample buildspec 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 env : variables : # TODO: replace \"v0.29.0\" with the latest version of tflint TFLINT_VERSION : \"0.29.0\" TFLINT_OS : \"amd64\" phases : install : commands : # Install tflint - wget https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/tflint_linux_${TFLINT_OS}.zip -O tflint.zip - unzip tflint.zip # Install tflint plugins - ./tflint --init pre_build : commands : - ./tflint With JUnit report 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 env : variables : # TODO: replace \"v0.29.0\" with the latest version of tflint TFLINT_VERSION : \"0.29.0\" TFLINT_OS : \"amd64\" phases : install : commands : # Install tflint - wget https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/tflint_linux_${TFLINT_OS}.zip -O tflint.zip - unzip tflint.zip # Install tflint plugins - ./tflint --init pre_build : commands : - ./tflint -f junit > tflint_report.xml reports : tflint : files : - tflint_report.xml GitHub Actions \u00b6 Assuming that you are storing your terraform configuration files and a .tflint.hcl file at the root of your repository, and that you are using main as your target branch for pull requests, you can create a GitHub actions workflow file such as this one: Important Make sure that you include the aws-serverless plugin into your .tflint.hcl configuration file, otherwise tflint will not install this ruleset. See Installation for more information. Sample workflow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 name : tflint-serverless on : pull_request : branches : # TODO: replace this if you are not using 'main' as your target # branch for pull requests. - main jobs : tflint-serverless : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - name : Setup TFLint uses : terraform-linters/setup-tflint@v1 with : tflint_version : v0.29.0 - name : Install Terraform plugins run : tflint --init - name : Lint Terraform files run : tflint With JUnit report 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 name : tflint-serverless on : pull_request : branches : # TODO: replace this if you are not using 'main' as your target # branch for pull requests. - main jobs : tflint-serverless : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - name : Setup TFLint uses : terraform-linters/setup-tflint@v1 with : tflint_version : v0.29.0 - name : Install Terraform plugins run : tflint --init - name : Lint Terraform files run : tflint -f junit > tflint_report.xml - name : Publish test report uses : mikepenz/action-junit-report@v2 # Only run this step on failure if : ${{ failure() }} with : report_paths : cfn_lint_report.xml GitLab \u00b6 Assuming that you are storing your terraform configuration files and a .tflint.hcl file at the root of your repository, you can create a .gitlab-ci.yml file such as this one: Sample file 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 tflint-serverless : variables : # TODO: replace \"v0.29.0\" with the latest version of tflint TFLINT_VERSION : \"0.29.0\" TFLINT_OS : \"amd64\" only : - merge_requests script : # Install tflint - wget https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/tflint_linux_${TFLINT_OS}.zip -O tflint.zip - unzip tflint.zip # Install tflint plugins - ./tflint --init # Run tflint - ./tflint With JUnit report 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 tflint-serverless : variables : # TODO: replace \"v0.29.0\" with the latest version of tflint TFLINT_VERSION : \"0.29.0\" TFLINT_OS : \"amd64\" only : - merge_requests script : # Install tflint - wget https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/tflint_linux_${TFLINT_OS}.zip -O tflint.zip - unzip tflint.zip # Install tflint plugins - ./tflint --init # Run tflint - ./tflint -f junit > tflint_report.xml artifacts : when : always reports : junit : cfn_lint_report.xml","title":"With tflint"},{"location":"tflint/#tflint-plugin","text":"","title":"tflint plugin"},{"location":"tflint/#installation","text":"This plugin depends on tflint . If you use tflint version 0.29 or newer, you can leverage the tflint --init command to automatically install the plugin. Otherwise, you will need to download the tflint-ruleset-aws-serverless binary corresponding to your system from the releases page . You can enable the Serverless Rules plugin by adding a plugin section in the .tflint.hcl file in your project: 1 2 3 4 5 plugin \"aws-serverless\" { enabled = true version = \"0.1.8\" source = \"github.com/awslabs/serverless-rules\" }","title":"Installation"},{"location":"tflint/#usage","text":"You can now run the tflint command, which will automatically use the Serverless Rules plugin: 1 tflint You can also try with a Terraform example provided in this repository. From the root folder of the repository, you can run: 1 2 cd examples/tflint/ tflint","title":"Usage"},{"location":"tflint/#sample-outputs","text":"If the Terraform configuration files fulfill the requirements for all the rules, tflint will return an empty output. Otherwise, tflint will output recommendations. Matching template 1 2 $ tflint $ With recommendations 1 2 3 4 5 6 7 8 $ tflint 1 issue ( s ) found: Warning: \"tracing_config\" is not present. ( aws_lambda_function_tracing_rule ) on main.tf line 20 : $","title":"Sample outputs"},{"location":"tflint/#ignoring-rules","text":"Serverless Rules is a set of recommended practices. We recommend you to keep Error-level rules enabled. Non-error rules, for example Lambda Tracing , contain detailed scenarios on when it\u2019s safe to ignore them. When needed, you can ignore any specific rule that doesn\u2019t match your environment. Rules in tflint can be disabled either through the --disable-rule command-line argument or with the .tflint.hcl configuration file in the current working directory. See the tflint user guide for more information. Command line 1 2 # Disable the aws_lambda_function_tracing_rule rule tflint --disable-rule aws_lambda_function_tracing_rule .tflint.hcl 1 2 3 4 5 6 7 8 9 10 plugin \"aws-serverless\" { enabled = true version = \"0.1.6\" source = \"github.com/awslabs/serverless-rules\" } # Disable the aws_lambda_function_tracing_rule rule rule \"aws_lambda_function_tracing_rule\" { enabled = false }","title":"Ignoring rules"},{"location":"tflint/#continuous-integration","text":"You can use Serverless Rules and tflint with your continuous integration tool to automatically check CloudFormation templates with rules from this project. For example, you can validate on pull requests, merge to your main branch, or before deploying to production. If there are any issues with your template, tflint will return a non-zero error code.","title":"Continuous integration"},{"location":"tflint/#aws-codebuild","text":"Assuming that you are storing your terraform configuration files and a .tflint.hcl file at the root of your repository, you can create a buildspec file such as this one. Important Make sure that you include the aws-serverless plugin into your .tflint.hcl configuration file, otherwise tflint will not install this ruleset. See Installation for more information. Sample buildspec 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 env : variables : # TODO: replace \"v0.29.0\" with the latest version of tflint TFLINT_VERSION : \"0.29.0\" TFLINT_OS : \"amd64\" phases : install : commands : # Install tflint - wget https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/tflint_linux_${TFLINT_OS}.zip -O tflint.zip - unzip tflint.zip # Install tflint plugins - ./tflint --init pre_build : commands : - ./tflint With JUnit report 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 env : variables : # TODO: replace \"v0.29.0\" with the latest version of tflint TFLINT_VERSION : \"0.29.0\" TFLINT_OS : \"amd64\" phases : install : commands : # Install tflint - wget https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/tflint_linux_${TFLINT_OS}.zip -O tflint.zip - unzip tflint.zip # Install tflint plugins - ./tflint --init pre_build : commands : - ./tflint -f junit > tflint_report.xml reports : tflint : files : - tflint_report.xml","title":"AWS CodeBuild"},{"location":"tflint/#github-actions","text":"Assuming that you are storing your terraform configuration files and a .tflint.hcl file at the root of your repository, and that you are using main as your target branch for pull requests, you can create a GitHub actions workflow file such as this one: Important Make sure that you include the aws-serverless plugin into your .tflint.hcl configuration file, otherwise tflint will not install this ruleset. See Installation for more information. Sample workflow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 name : tflint-serverless on : pull_request : branches : # TODO: replace this if you are not using 'main' as your target # branch for pull requests. - main jobs : tflint-serverless : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - name : Setup TFLint uses : terraform-linters/setup-tflint@v1 with : tflint_version : v0.29.0 - name : Install Terraform plugins run : tflint --init - name : Lint Terraform files run : tflint With JUnit report 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 name : tflint-serverless on : pull_request : branches : # TODO: replace this if you are not using 'main' as your target # branch for pull requests. - main jobs : tflint-serverless : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - name : Setup TFLint uses : terraform-linters/setup-tflint@v1 with : tflint_version : v0.29.0 - name : Install Terraform plugins run : tflint --init - name : Lint Terraform files run : tflint -f junit > tflint_report.xml - name : Publish test report uses : mikepenz/action-junit-report@v2 # Only run this step on failure if : ${{ failure() }} with : report_paths : cfn_lint_report.xml","title":"GitHub Actions"},{"location":"tflint/#gitlab","text":"Assuming that you are storing your terraform configuration files and a .tflint.hcl file at the root of your repository, you can create a .gitlab-ci.yml file such as this one: Sample file 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 tflint-serverless : variables : # TODO: replace \"v0.29.0\" with the latest version of tflint TFLINT_VERSION : \"0.29.0\" TFLINT_OS : \"amd64\" only : - merge_requests script : # Install tflint - wget https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/tflint_linux_${TFLINT_OS}.zip -O tflint.zip - unzip tflint.zip # Install tflint plugins - ./tflint --init # Run tflint - ./tflint With JUnit report 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 tflint-serverless : variables : # TODO: replace \"v0.29.0\" with the latest version of tflint TFLINT_VERSION : \"0.29.0\" TFLINT_OS : \"amd64\" only : - merge_requests script : # Install tflint - wget https://github.com/terraform-linters/tflint/releases/download/v${TFLINT_VERSION}/tflint_linux_${TFLINT_OS}.zip -O tflint.zip - unzip tflint.zip # Install tflint plugins - ./tflint --init # Run tflint - ./tflint -f junit > tflint_report.xml artifacts : when : always reports : junit : cfn_lint_report.xml","title":"GitLab"},{"location":"contributing/create_rule/","text":"Creating rules \u00b6 If you are thinking of creating or proposing a new rule, please follow the process outline below. The first step before adding a new rule is to submit an issue to collect feedback from other members of the community. Create an issue \u00b6 Before starting the implementation of a new rule, please create an issue using the New rule template . This will allow members of the community to provide feedback on its implementation, if it meets the needs of most serverless users, if it's the right level, etc. Template for cfn-lint rules \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # TODO: set the rule name class __Rule ( CloudFormationLintRule ): # TODO: set docstring \"\"\" Ensure that ... \"\"\" # TODO: update these values id = \"...\" # noqa: VNE003 shortdesc = \"...\" description = \"Ensure that ...\" source_url = \"...\" tags = [ \"lambda\" ] _message = \"... {} ...\" def match ( self , cfn ): # TODO: update docstring \"\"\" Match against ... \"\"\" matches = [] # TODO: set resource type for key , value in cfn . get_resources ([ \"...\" ]) . items (): # TODO: set property name prop = value . get ( \"Properties\" , {}) . get ( \"...\" , None ) if prop is None : matches . append ( RuleMatch ([ \"Resources\" , key ], self . _message . format ( key ))) return matches Template for documentation \u00b6 Please use the following template when writing documentation for a rule. Each rule goes into a separate markdown file into the relevant service folder. For example, a rule for AWS Lambda would go into the docs/rules/lambda/ folder. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 # _Service Name Rule name_ __Level__ : _Rule level_ {: class=\"badge badge-red\" } __Initial version__ : _release version_ {: class=\"badge badge-blue\" } __cfn-lint__ : _cfn-lint rule ID_ {: class=\"badge\" } __tflint__ : _tflint rule name_ {: class=\"badge\" } _Short explanation on the rule_ ## Implementations === \"CDK\" ```typescript // Imports here export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); // Implementation } } ``` === \"CloudFormation (JSON)\" ```json { \"Resources\" : { // Add resources here } } ``` === \"CloudFormation (YAML)\" ```yaml Resources : # Add resources here ``` === \"Serverless Framework\" ```yaml provider : name : aws # Add provider-specific configuration here resources : # Add resources here ``` === \"Terraform\" ```tf # Add Terraform resources here ``` ## See also * _List of links to the relevant documentation, from sources such as AWS Well-Architected, service documentation, etc._","title":"Creating rules"},{"location":"contributing/create_rule/#creating-rules","text":"If you are thinking of creating or proposing a new rule, please follow the process outline below. The first step before adding a new rule is to submit an issue to collect feedback from other members of the community.","title":"Creating rules"},{"location":"contributing/create_rule/#create-an-issue","text":"Before starting the implementation of a new rule, please create an issue using the New rule template . This will allow members of the community to provide feedback on its implementation, if it meets the needs of most serverless users, if it's the right level, etc.","title":"Create an issue"},{"location":"contributing/create_rule/#template-for-cfn-lint-rules","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # TODO: set the rule name class __Rule ( CloudFormationLintRule ): # TODO: set docstring \"\"\" Ensure that ... \"\"\" # TODO: update these values id = \"...\" # noqa: VNE003 shortdesc = \"...\" description = \"Ensure that ...\" source_url = \"...\" tags = [ \"lambda\" ] _message = \"... {} ...\" def match ( self , cfn ): # TODO: update docstring \"\"\" Match against ... \"\"\" matches = [] # TODO: set resource type for key , value in cfn . get_resources ([ \"...\" ]) . items (): # TODO: set property name prop = value . get ( \"Properties\" , {}) . get ( \"...\" , None ) if prop is None : matches . append ( RuleMatch ([ \"Resources\" , key ], self . _message . format ( key ))) return matches","title":"Template for cfn-lint rules"},{"location":"contributing/create_rule/#template-for-documentation","text":"Please use the following template when writing documentation for a rule. Each rule goes into a separate markdown file into the relevant service folder. For example, a rule for AWS Lambda would go into the docs/rules/lambda/ folder. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 # _Service Name Rule name_ __Level__ : _Rule level_ {: class=\"badge badge-red\" } __Initial version__ : _release version_ {: class=\"badge badge-blue\" } __cfn-lint__ : _cfn-lint rule ID_ {: class=\"badge\" } __tflint__ : _tflint rule name_ {: class=\"badge\" } _Short explanation on the rule_ ## Implementations === \"CDK\" ```typescript // Imports here export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); // Implementation } } ``` === \"CloudFormation (JSON)\" ```json { \"Resources\" : { // Add resources here } } ``` === \"CloudFormation (YAML)\" ```yaml Resources : # Add resources here ``` === \"Serverless Framework\" ```yaml provider : name : aws # Add provider-specific configuration here resources : # Add resources here ``` === \"Terraform\" ```tf # Add Terraform resources here ``` ## See also * _List of links to the relevant documentation, from sources such as AWS Well-Architected, service documentation, etc._","title":"Template for documentation"},{"location":"rules/","text":"Rules \u00b6 Rule levels \u00b6 A rule can have one of the following three rule levels: Error, Warning, or Info. An Error level for a rule means this is a recommended practice for the vast majority of circumstances. A Warning level means that this is a recommended practice, but you can achieve similar results through a different implementation. For example, you can create alarms through third party offering , rather than using AWS CloudWatch. An Info level means that this does not necessarily align with recommended practices but can point out potential issues or misconfiguration. For example, an Amazon EventBridge event bus without any rules associated with it, as you might create those rules through a different template. AWS Lambda \u00b6 Level Name cfn-lint tflint Warning Lambda Tracing WS1000 aws_lambda_function_tracing_rule Error EventSourceMapping Failure Destination ES1001 aws_lambda_event_source_mapping_failure_destination Warning Lambda Permission Multiple Principals WS1002 aws_lambda_permission_multiple_principals Warning Lambda Star Permissions WS1003 Not implemented Warning Lambda Log Retention WS1004 Not implemented Error Lambda Default Memory Size ES1005 aws_lambda_function_default_memory Error Lambda Default Timeout ES1006 aws_lambda_function_default_timeout Error Async Lambda Failure Destination ES1007 aws_lambda_event_invoke_config_async_on_failure Error Lambda EOL Runtime E2531 aws_lambda_function_eol_runtime Amazon API Gateway REST APIs \u00b6 Level Name cfn-lint tflint Error API Gateway Logging ES2000 aws_apigateway_stage_logging_rule Warning API Gateway Structured Logging WS2001 aws_api_gateway_stage_structured_logging Warning API Gateway Tracing WS2002 aws_apigateway_stage_tracing_rule Warning API Gateway Default Throttling ES2003 aws_apigateway_stage_throttling_rule Amazon API Gateway HTTP APIs \u00b6 Level Name cfn-lint tflint Error API Gateway Logging ES2000 aws_apigatewayv2_stage_logging_rule Warning API Gateway Structured Logging WS2001 aws_apigatewayv2_stage_structured_logging Warning API Gateway Default Throttling ES2003 aws_apigatewayv2_stage_throttling_rule AWS AppSync \u00b6 Level Name cfn-lint tflint Error AppSync Tracing WS3000 aws_appsync_graphql_api_tracing_rule Amazon EventBridge \u00b6 Level Name cfn-lint tflint Error EventBridge Rule Without DLQ ES4000 aws_cloudwatch_event_target_no_dlq Amazon SNS \u00b6 Level Name cfn-lint tflint Error SNS Redrive Policy ES7000 aws_sns_topic_subscription_redrive_policy Amazon SQS \u00b6 Level Name cfn-lint tflint Error SQS Redrive Policy ES6000 aws_sqs_queue_redrive_policy Amazon Step Functions \u00b6 Level Name cfn-lint tflint Warning Step Functions Tracing WS5000 aws_sfn_state_machine_tracing","title":"Rules"},{"location":"rules/#rules","text":"","title":"Rules"},{"location":"rules/#rule-levels","text":"A rule can have one of the following three rule levels: Error, Warning, or Info. An Error level for a rule means this is a recommended practice for the vast majority of circumstances. A Warning level means that this is a recommended practice, but you can achieve similar results through a different implementation. For example, you can create alarms through third party offering , rather than using AWS CloudWatch. An Info level means that this does not necessarily align with recommended practices but can point out potential issues or misconfiguration. For example, an Amazon EventBridge event bus without any rules associated with it, as you might create those rules through a different template.","title":"Rule levels"},{"location":"rules/#aws-lambda","text":"Level Name cfn-lint tflint Warning Lambda Tracing WS1000 aws_lambda_function_tracing_rule Error EventSourceMapping Failure Destination ES1001 aws_lambda_event_source_mapping_failure_destination Warning Lambda Permission Multiple Principals WS1002 aws_lambda_permission_multiple_principals Warning Lambda Star Permissions WS1003 Not implemented Warning Lambda Log Retention WS1004 Not implemented Error Lambda Default Memory Size ES1005 aws_lambda_function_default_memory Error Lambda Default Timeout ES1006 aws_lambda_function_default_timeout Error Async Lambda Failure Destination ES1007 aws_lambda_event_invoke_config_async_on_failure Error Lambda EOL Runtime E2531 aws_lambda_function_eol_runtime","title":"AWS Lambda"},{"location":"rules/#amazon-api-gateway-rest-apis","text":"Level Name cfn-lint tflint Error API Gateway Logging ES2000 aws_apigateway_stage_logging_rule Warning API Gateway Structured Logging WS2001 aws_api_gateway_stage_structured_logging Warning API Gateway Tracing WS2002 aws_apigateway_stage_tracing_rule Warning API Gateway Default Throttling ES2003 aws_apigateway_stage_throttling_rule","title":"Amazon API Gateway REST APIs"},{"location":"rules/#amazon-api-gateway-http-apis","text":"Level Name cfn-lint tflint Error API Gateway Logging ES2000 aws_apigatewayv2_stage_logging_rule Warning API Gateway Structured Logging WS2001 aws_apigatewayv2_stage_structured_logging Warning API Gateway Default Throttling ES2003 aws_apigatewayv2_stage_throttling_rule","title":"Amazon API Gateway HTTP APIs"},{"location":"rules/#aws-appsync","text":"Level Name cfn-lint tflint Error AppSync Tracing WS3000 aws_appsync_graphql_api_tracing_rule","title":"AWS AppSync"},{"location":"rules/#amazon-eventbridge","text":"Level Name cfn-lint tflint Error EventBridge Rule Without DLQ ES4000 aws_cloudwatch_event_target_no_dlq","title":"Amazon EventBridge"},{"location":"rules/#amazon-sns","text":"Level Name cfn-lint tflint Error SNS Redrive Policy ES7000 aws_sns_topic_subscription_redrive_policy","title":"Amazon SNS"},{"location":"rules/#amazon-sqs","text":"Level Name cfn-lint tflint Error SQS Redrive Policy ES6000 aws_sqs_queue_redrive_policy","title":"Amazon SQS"},{"location":"rules/#amazon-step-functions","text":"Level Name cfn-lint tflint Warning Step Functions Tracing WS5000 aws_sfn_state_machine_tracing","title":"Amazon Step Functions"},{"location":"rules/api_gateway/default_throttling/","text":"API Gateway Default Throttling \u00b6 Level : Error Initial version : 0.1.3 cfn-lint : ES2003 tflint (REST) : aws_apigateway_stage_throttling_rule tflint (HTTP) : aws_apigatewayv2_stage_throttling_rule Amazon API Gateway supports defining default limits for an API to prevent it from being overwhelmed by too many requests. This uses a token bucket algorithm , where a token counts for a single request. Implementations for REST APIs \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { RestApi } from '@aws-cdk/aws-apigateway' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myApi = new RestApi ( scope , 'MyApi' , { deployOptions : { // Throttling for default methods methodOptions : { '*/*' : { throttlingBurstLimit : 1000 , throttlingRateLimite : 10 , } } }, } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"Resources\" : { \"MyApi\" : { \"Type\" : \"AWS::Serverless::Api\" , \"Properties\" : { \"DefinitionUri\" : \"openapi.yaml\" , \"StageName\" : \"prod\" , // Thro ttl i n g f or de fault me t hods by se tt i n g H tt pMe t hod t o '*' a n d // ResourcePa t h t o '/*' \"MethodSettings\" : [{ \"HttpMethod\" : \"*\" , \"ResourcePath\" : \"/*\" , \"ThrottlingRateLimit\" : 10 , \"ThrottlingBurstLimit\" : 1000 }] } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Resources : MyApi : Type : AWS::Serverless::Api Properties : DefinitionUri : openapi.yaml StageName : prod # Throttling for default methods by setting HttpMethod to '*' and # ResourcePath to '/*' MethodSettings : - HttpMethod : \"*\" ResourcePath : \"/*\" ThrottlingRateLimit : 10 ThrottlingBurstLimit : 1000 Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 resources : Resources : MyApi : Type : AWS::Serverless::Api Properties : DefinitionUri : openapi.yaml StageName : prod # Throttling for default methods by setting HttpMethod to '*' and # ResourcePath to '/*' MethodSettings : - HttpMethod : \"*\" ResourcePath : \"/*\" ThrottlingRateLimit : 10 ThrottlingBurstLimit : 1000 Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 resource \"aws_api_gateway_stage\" \"this\" { body = file ( \"openapi.yaml\" ) } resource \"aws_api_gateway_deployment\" \"this\" { rest_api_id = aws_api_gateway_rest_api.this.id triggers = { redeployment = sha1 ( jsonencode ( aws_api_gateway_rest_api.this.body )) } lifecycle { create_before_destroy = true } } resource \"aws_api_gateway_stage\" \"this\" { deployment_id = aws_api_gateway_deployment.this.id rest_api_id = aws_api_gateway_rest_api.this.id stage_name = \"prod\" } # Throttling for default methods by setting method_path to '*/*' resource \"aws_api_gateway_method_settings\" \"this\" { rest_api_id = aws_api_gateway_rest_api.this.id stage_name = aws_api_gateway_stage.this.stage_name method_path = \"*/*\" settings { throttling_burst_limit = 1000 throttling_rate_limit = 10 } } Implementations for HTTP APIs \u00b6 CDK Remark : this is currently not supported in AWS CDK as an L2 construct at the moment. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { CfnStage , HttpApi } from '@aws-cdk/aws-apigatewayv2' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myApi = new HttpApi ( scope , 'MyApi' ); // Throttling for default methods by setting method_path to '*/* using escape hatch. // See https://docs.aws.amazon.com/cdk/latest/guide/cfn_layer.html#cfn_layer_resource // for more information. const defaultStage = myApi . defaultStage . node . defaultChild as CfnStage ; defaultStage . defaultRouteSettings = { throttlingBurstLimit = 1000 , throttlingRateLimit = 10 , }; } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"Resources\" : { \"MyApi\" : { \"Type\" : \"AWS::Serverless::HttpApi\" , \"Properties\" : { \"DefinitionUri\" : \"openapi.yaml\" , \"StageName\" : \"prod\" , \"DefaultRouteSettings\" : { \"ThrottlingBurstLimit\" : 1000 , \"ThrottlingRateLimit\" : 10 } } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 Resources : MyApi : Type : AWS::Serverless::HttpApi Properties : DefinitionUri : \"openapi.yaml\" StageName : prod DefaultRouteSettings : ThrottlingBurstLimit : 1000 ThrottlingRateLimit : 10 Serverless Framework 1 2 3 4 5 6 7 8 9 10 resources : Resources : MyApi : Type : AWS::Serverless::HttpApi Properties : DefinitionUri : \"openapi.yaml\" StageName : prod DefaultRouteSettings : ThrottlingBurstLimit : 1000 ThrottlingRateLimit : 10 Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 resource \"aws_apigatewayv2_api\" \"this\" { name = \"my-api\" protocol_type = \"HTTP\" body = file ( \"openapi.yaml\" ) } resource \"aws_apigatewayv2_stage\" \"this\" { api_id = aws_apigatewayv2_api.this.id name = \"prod\" # Default throttling settings default_route_settings { throttling_burst_limit = 1000 throttling_rate_limit = 10 } } See also \u00b6 Throttle API requests for better throughput Throttling requests to your HTTP API","title":"API Gateway Default Throttling"},{"location":"rules/api_gateway/default_throttling/#api-gateway-default-throttling","text":"Level : Error Initial version : 0.1.3 cfn-lint : ES2003 tflint (REST) : aws_apigateway_stage_throttling_rule tflint (HTTP) : aws_apigatewayv2_stage_throttling_rule Amazon API Gateway supports defining default limits for an API to prevent it from being overwhelmed by too many requests. This uses a token bucket algorithm , where a token counts for a single request.","title":"API Gateway Default Throttling"},{"location":"rules/api_gateway/default_throttling/#implementations-for-rest-apis","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { RestApi } from '@aws-cdk/aws-apigateway' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myApi = new RestApi ( scope , 'MyApi' , { deployOptions : { // Throttling for default methods methodOptions : { '*/*' : { throttlingBurstLimit : 1000 , throttlingRateLimite : 10 , } } }, } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"Resources\" : { \"MyApi\" : { \"Type\" : \"AWS::Serverless::Api\" , \"Properties\" : { \"DefinitionUri\" : \"openapi.yaml\" , \"StageName\" : \"prod\" , // Thro ttl i n g f or de fault me t hods by se tt i n g H tt pMe t hod t o '*' a n d // ResourcePa t h t o '/*' \"MethodSettings\" : [{ \"HttpMethod\" : \"*\" , \"ResourcePath\" : \"/*\" , \"ThrottlingRateLimit\" : 10 , \"ThrottlingBurstLimit\" : 1000 }] } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Resources : MyApi : Type : AWS::Serverless::Api Properties : DefinitionUri : openapi.yaml StageName : prod # Throttling for default methods by setting HttpMethod to '*' and # ResourcePath to '/*' MethodSettings : - HttpMethod : \"*\" ResourcePath : \"/*\" ThrottlingRateLimit : 10 ThrottlingBurstLimit : 1000 Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 resources : Resources : MyApi : Type : AWS::Serverless::Api Properties : DefinitionUri : openapi.yaml StageName : prod # Throttling for default methods by setting HttpMethod to '*' and # ResourcePath to '/*' MethodSettings : - HttpMethod : \"*\" ResourcePath : \"/*\" ThrottlingRateLimit : 10 ThrottlingBurstLimit : 1000 Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 resource \"aws_api_gateway_stage\" \"this\" { body = file ( \"openapi.yaml\" ) } resource \"aws_api_gateway_deployment\" \"this\" { rest_api_id = aws_api_gateway_rest_api.this.id triggers = { redeployment = sha1 ( jsonencode ( aws_api_gateway_rest_api.this.body )) } lifecycle { create_before_destroy = true } } resource \"aws_api_gateway_stage\" \"this\" { deployment_id = aws_api_gateway_deployment.this.id rest_api_id = aws_api_gateway_rest_api.this.id stage_name = \"prod\" } # Throttling for default methods by setting method_path to '*/*' resource \"aws_api_gateway_method_settings\" \"this\" { rest_api_id = aws_api_gateway_rest_api.this.id stage_name = aws_api_gateway_stage.this.stage_name method_path = \"*/*\" settings { throttling_burst_limit = 1000 throttling_rate_limit = 10 } }","title":"Implementations for REST APIs"},{"location":"rules/api_gateway/default_throttling/#implementations-for-http-apis","text":"CDK Remark : this is currently not supported in AWS CDK as an L2 construct at the moment. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { CfnStage , HttpApi } from '@aws-cdk/aws-apigatewayv2' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myApi = new HttpApi ( scope , 'MyApi' ); // Throttling for default methods by setting method_path to '*/* using escape hatch. // See https://docs.aws.amazon.com/cdk/latest/guide/cfn_layer.html#cfn_layer_resource // for more information. const defaultStage = myApi . defaultStage . node . defaultChild as CfnStage ; defaultStage . defaultRouteSettings = { throttlingBurstLimit = 1000 , throttlingRateLimit = 10 , }; } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"Resources\" : { \"MyApi\" : { \"Type\" : \"AWS::Serverless::HttpApi\" , \"Properties\" : { \"DefinitionUri\" : \"openapi.yaml\" , \"StageName\" : \"prod\" , \"DefaultRouteSettings\" : { \"ThrottlingBurstLimit\" : 1000 , \"ThrottlingRateLimit\" : 10 } } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 Resources : MyApi : Type : AWS::Serverless::HttpApi Properties : DefinitionUri : \"openapi.yaml\" StageName : prod DefaultRouteSettings : ThrottlingBurstLimit : 1000 ThrottlingRateLimit : 10 Serverless Framework 1 2 3 4 5 6 7 8 9 10 resources : Resources : MyApi : Type : AWS::Serverless::HttpApi Properties : DefinitionUri : \"openapi.yaml\" StageName : prod DefaultRouteSettings : ThrottlingBurstLimit : 1000 ThrottlingRateLimit : 10 Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 resource \"aws_apigatewayv2_api\" \"this\" { name = \"my-api\" protocol_type = \"HTTP\" body = file ( \"openapi.yaml\" ) } resource \"aws_apigatewayv2_stage\" \"this\" { api_id = aws_apigatewayv2_api.this.id name = \"prod\" # Default throttling settings default_route_settings { throttling_burst_limit = 1000 throttling_rate_limit = 10 } }","title":"Implementations for HTTP APIs"},{"location":"rules/api_gateway/default_throttling/#see-also","text":"Throttle API requests for better throughput Throttling requests to your HTTP API","title":"See also"},{"location":"rules/api_gateway/logging/","text":"API Gateway Logging \u00b6 Level : Error Initial version : 0.1.3 cfn-lint : ES2000 tflint (REST) : aws_apigateway_stage_logging_rule tflint (HTTP) : aws_apigatewayv2_stage_logging_rule Amazon API Gateway can send logs to Amazon CloudWatch Logs and Amazon Kinesis Data Firehose for centralization. Implementations for REST APIs \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import { LogGroup } from '@aws-cdk/aws-logs' ; import { LogGroupLogDestination , RestApi } from '@aws-cdk/aws-apigateway' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myLogGroup = new LogGroup ( scope , 'MyLogGroup' ); const myApi = new RestApi ( scope , 'MyApi' , { deployOptions : { // Setup logging for API Gateway accessLogDestination : new LogGroupLogDestination ( myLogGroup ), accessLogFormat : JSON.stringify ({ \"stage\" : \"$context.stage\" , \"request_id\" : \"$context.requestId\" , \"api_id\" : \"$context.apiId\" , \"resource_path\" : \"$context.resourcePath\" , \"resource_id\" : \"$context.resourceId\" , \"http_method\" : \"$context.httpMethod\" , \"source_ip\" : \"$context.identity.sourceIp\" , \"user-agent\" : \"$context.identity.userAgent\" , \"account_id\" : \"$context.identity.accountId\" , \"api_key\" : \"$context.identity.apiKey\" , \"caller\" : \"$context.identity.caller\" , \"user\" : \"$context.identity.user\" , \"user_arn\" : \"$context.identity.userArn\" , \"integration_latency\" : $context . integration . latency }), } } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"Resource\" : { \"Type\" : \"AWS::Serverless::Api\" , \"Properties\" : { \"DefinitionUri\" : \"openapi.yaml\" , \"StageName\" : \"prod\" , // Se tu p loggi n g f or API Ga te way \"AccessLogSetting\" :{ \"DestinationArn\" : \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\" , \"Format\" : \"{ \\\"stage\\\" : \\\"$context.stage\\\", \\\"request_id\\\" : \\\"$context.requestId\\\", \\\"api_id\\\" : \\\"$context.apiId\\\", \\\"resource_path\\\" : \\\"$context.resourcePath\\\", \\\"resource_id\\\" : \\\"$context.resourceId\\\", \\\"http_method\\\" : \\\"$context.httpMethod\\\", \\\"source_ip\\\" : \\\"$context.identity.sourceIp\\\", \\\"user-agent\\\" : \\\"$context.identity.userAgent\\\", \\\"account_id\\\" : \\\"$context.identity.accountId\\\", \\\"api_key\\\" : \\\"$context.identity.apiKey\\\", \\\"caller\\\" : \\\"$context.identity.caller\\\", \\\"user\\\" : \\\"$context.identity.user\\\", \\\"user_arn\\\" : \\\"$context.identity.userArn\\\", \\\"integration_latency\\\": $context.integration.latency }\" } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Resources : Api : Type : AWS::Serverless::Api Properties : DefinitionUri : openapi.yaml StageName : prod # Setup logging for API Gateway AccessLogSetting : DestinationArn : \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\" Format : | { \"stage\" : \"$context.stage\", \"request_id\" : \"$context.requestId\", \"api_id\" : \"$context.apiId\", \"resource_path\" : \"$context.resourcePath\", \"resource_id\" : \"$context.resourceId\", \"http_method\" : \"$context.httpMethod\", \"source_ip\" : \"$context.identity.sourceIp\", \"user-agent\" : \"$context.identity.userAgent\", \"account_id\" : \"$context.identity.accountId\", \"api_key\" : \"$context.identity.apiKey\", \"caller\" : \"$context.identity.caller\", \"user\" : \"$context.identity.user\", \"user_arn\" : \"$context.identity.userArn\", \"integration_latency\": $context.integration.latency } Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 provider : name : aws logs : # Setup logging for API Gateway restApi : accessLogging : true format : | { \"stage\" : \"$context.stage\", \"request_id\" : \"$context.requestId\", \"api_id\" : \"$context.apiId\", \"resource_path\" : \"$context.resourcePath\", \"resource_id\" : \"$context.resourceId\", \"http_method\" : \"$context.httpMethod\", \"source_ip\" : \"$context.identity.sourceIp\", \"user-agent\" : \"$context.identity.userAgent\", \"account_id\" : \"$context.identity.accountId\", \"api_key\" : \"$context.identity.apiKey\", \"caller\" : \"$context.identity.caller\", \"user\" : \"$context.identity.user\", \"user_arn\" : \"$context.identity.userArn\", \"integration_latency\": $context.integration.latency } Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 resource \"aws_api_gateway_rest_api\" \"this\" { body = file ( \"openapi.yaml\" ) } resource \"aws_api_gateway_deployment\" \"this\" { rest_api_id = aws_api_gateway_rest_api.this.id triggers = { redeployment = sha1 ( jsonencode ( aws_api_gateway_rest_api.this.body )) } lifecycle { create_before_destroy = true } } resource \"aws_api_gateway_stage\" \"this\" { deployment_id = aws_api_gateway_deployment.this.id rest_api_id = aws_api_gateway_rest_api.this.id stage_name = \"prod\" # Setup logging for API Gateway access_log_settings { destination_arn = \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\" format = << EOF { \"stage\" : \"$context.stage\" , \"request_id\" : \"$context.requestId\" , \"api_id\" : \"$context.apiId\" , \"resource_path\" : \"$context.resourcePath\" , \"resource_id\" : \"$context.resourceId\" , \"http_method\" : \"$context.httpMethod\" , \"source_ip\" : \"$context.identity.sourceIp\" , \"user-agent\" : \"$context.identity.userAgent\" , \"account_id\" : \"$context.identity.accountId\" , \"api_key\" : \"$context.identity.apiKey\" , \"caller\" : \"$context.identity.caller\" , \"user\" : \"$context.identity.user\" , \"user_arn\" : \"$context.identity.userArn\" , \"integration_latency\" : $ context.integration.latency } EOF } } Implementations for HTTP APIs \u00b6 CDK Remark : this is currently not supported in AWS CDK as an L2 construct at the moment. See this GitHub issue for more details. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import { CfnStage , HttpApi } from '@aws-cdk/aws-apigatewayv2' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myApi = new HttpApi ( scope , 'MyApi' ); // Setup logging for API Gateway using escape hatch. // See https://github.com/aws/aws-cdk/issues/11100 and // https://docs.aws.amazon.com/cdk/latest/guide/cfn_layer.html#cfn_layer_resource // for more information. const defaultStage = myApi . defaultStage . node . defaultChild as CfnStage ; defaultStage . accessLogSettings = { destinationArn : '' , format : JSON.stringify ({ \"stage\" : \"$context.stage\" , \"request_id\" : \"$context.requestId\" , \"api_id\" : \"$context.apiId\" , \"resource_path\" : \"$context.resourcePath\" , \"resource_id\" : \"$context.resourceId\" , \"http_method\" : \"$context.httpMethod\" , \"source_ip\" : \"$context.identity.sourceIp\" , \"user-agent\" : \"$context.identity.userAgent\" , \"account_id\" : \"$context.identity.accountId\" , \"api_key\" : \"$context.identity.apiKey\" , \"caller\" : \"$context.identity.caller\" , \"user\" : \"$context.identity.user\" , \"user_arn\" : \"$context.identity.userArn\" , \"integration_latency\" : $context . integration . latency }), }; } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"Resource\" : { \"Type\" : \"AWS::Serverless::HttpApi\" , \"Properties\" : { \"DefinitionUri\" : \"openapi.yaml\" , \"StageName\" : \"prod\" , // Se tu p loggi n g f or API Ga te way \"AccessLogSettings\" :{ \"DestinationArn\" : \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\" , \"Format\" : \"{ \\\"stage\\\" : \\\"$context.stage\\\", \\\"request_id\\\" : \\\"$context.requestId\\\", \\\"api_id\\\" : \\\"$context.apiId\\\", \\\"resource_path\\\" : \\\"$context.resourcePath\\\", \\\"resource_id\\\" : \\\"$context.resourceId\\\", \\\"http_method\\\" : \\\"$context.httpMethod\\\", \\\"source_ip\\\" : \\\"$context.identity.sourceIp\\\", \\\"user-agent\\\" : \\\"$context.identity.userAgent\\\", \\\"account_id\\\" : \\\"$context.identity.accountId\\\", \\\"api_key\\\" : \\\"$context.identity.apiKey\\\", \\\"caller\\\" : \\\"$context.identity.caller\\\", \\\"user\\\" : \\\"$context.identity.user\\\", \\\"user_arn\\\" : \\\"$context.identity.userArn\\\", \\\"integration_latency\\\": $context.integration.latency }\" } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Resources : Api : Type : AWS::Serverless::HttpApi Properties : DefinitionUri : openapi.yaml StageName : prod # Setup logging for API Gateway AccessLogSettings : DestinationArn : \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\" Format : | { \"stage\" : \"$context.stage\", \"request_id\" : \"$context.requestId\", \"api_id\" : \"$context.apiId\", \"resource_path\" : \"$context.resourcePath\", \"resource_id\" : \"$context.resourceId\", \"http_method\" : \"$context.httpMethod\", \"source_ip\" : \"$context.identity.sourceIp\", \"user-agent\" : \"$context.identity.userAgent\", \"account_id\" : \"$context.identity.accountId\", \"api_key\" : \"$context.identity.apiKey\", \"caller\" : \"$context.identity.caller\", \"user\" : \"$context.identity.user\", \"user_arn\" : \"$context.identity.userArn\", \"integration_latency\": $context.integration.latency } Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 provider : name : aws logs : httpApi : format : | { \"stage\" : \"$context.stage\", \"request_id\" : \"$context.requestId\", \"api_id\" : \"$context.apiId\", \"resource_path\" : \"$context.resourcePath\", \"resource_id\" : \"$context.resourceId\", \"http_method\" : \"$context.httpMethod\", \"source_ip\" : \"$context.identity.sourceIp\", \"user-agent\" : \"$context.identity.userAgent\", \"account_id\" : \"$context.identity.accountId\", \"api_key\" : \"$context.identity.apiKey\", \"caller\" : \"$context.identity.caller\", \"user\" : \"$context.identity.user\", \"user_arn\" : \"$context.identity.userArn\", \"integration_latency\": $context.integration.latency } Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 resource \"aws_apigatewayv2_api\" \"this\" { name = \"my-api\" protocol_type = \"HTTP\" body = file ( \"openapi.yaml\" ) } resource \"aws_apigatewayv2_stage\" \"this\" { api_id = aws_apigatewayv2_api.this.id name = \"prod\" # Setup logging for API Gateway access_log_settings { destination_arn = \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\" format = << EOF { \"stage\" : \"$context.stage\" , \"request_id\" : \"$context.requestId\" , \"api_id\" : \"$context.apiId\" , \"resource_path\" : \"$context.resourcePath\" , \"resource_id\" : \"$context.resourceId\" , \"http_method\" : \"$context.httpMethod\" , \"source_ip\" : \"$context.identity.sourceIp\" , \"user-agent\" : \"$context.identity.userAgent\" , \"account_id\" : \"$context.identity.accountId\" , \"api_key\" : \"$context.identity.apiKey\" , \"caller\" : \"$context.identity.caller\" , \"user\" : \"$context.identity.user\" , \"user_arn\" : \"$context.identity.userArn\" , \"integration_latency\" : $ context.integration.latency } EOF } } See also \u00b6 Serverless Lens: Centralized and structured logging Monitoring REST APIs Monitoring your HTTP API Monitoring WebSocket APIs","title":"API Gateway Logging"},{"location":"rules/api_gateway/logging/#api-gateway-logging","text":"Level : Error Initial version : 0.1.3 cfn-lint : ES2000 tflint (REST) : aws_apigateway_stage_logging_rule tflint (HTTP) : aws_apigatewayv2_stage_logging_rule Amazon API Gateway can send logs to Amazon CloudWatch Logs and Amazon Kinesis Data Firehose for centralization.","title":"API Gateway Logging"},{"location":"rules/api_gateway/logging/#implementations-for-rest-apis","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import { LogGroup } from '@aws-cdk/aws-logs' ; import { LogGroupLogDestination , RestApi } from '@aws-cdk/aws-apigateway' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myLogGroup = new LogGroup ( scope , 'MyLogGroup' ); const myApi = new RestApi ( scope , 'MyApi' , { deployOptions : { // Setup logging for API Gateway accessLogDestination : new LogGroupLogDestination ( myLogGroup ), accessLogFormat : JSON.stringify ({ \"stage\" : \"$context.stage\" , \"request_id\" : \"$context.requestId\" , \"api_id\" : \"$context.apiId\" , \"resource_path\" : \"$context.resourcePath\" , \"resource_id\" : \"$context.resourceId\" , \"http_method\" : \"$context.httpMethod\" , \"source_ip\" : \"$context.identity.sourceIp\" , \"user-agent\" : \"$context.identity.userAgent\" , \"account_id\" : \"$context.identity.accountId\" , \"api_key\" : \"$context.identity.apiKey\" , \"caller\" : \"$context.identity.caller\" , \"user\" : \"$context.identity.user\" , \"user_arn\" : \"$context.identity.userArn\" , \"integration_latency\" : $context . integration . latency }), } } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"Resource\" : { \"Type\" : \"AWS::Serverless::Api\" , \"Properties\" : { \"DefinitionUri\" : \"openapi.yaml\" , \"StageName\" : \"prod\" , // Se tu p loggi n g f or API Ga te way \"AccessLogSetting\" :{ \"DestinationArn\" : \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\" , \"Format\" : \"{ \\\"stage\\\" : \\\"$context.stage\\\", \\\"request_id\\\" : \\\"$context.requestId\\\", \\\"api_id\\\" : \\\"$context.apiId\\\", \\\"resource_path\\\" : \\\"$context.resourcePath\\\", \\\"resource_id\\\" : \\\"$context.resourceId\\\", \\\"http_method\\\" : \\\"$context.httpMethod\\\", \\\"source_ip\\\" : \\\"$context.identity.sourceIp\\\", \\\"user-agent\\\" : \\\"$context.identity.userAgent\\\", \\\"account_id\\\" : \\\"$context.identity.accountId\\\", \\\"api_key\\\" : \\\"$context.identity.apiKey\\\", \\\"caller\\\" : \\\"$context.identity.caller\\\", \\\"user\\\" : \\\"$context.identity.user\\\", \\\"user_arn\\\" : \\\"$context.identity.userArn\\\", \\\"integration_latency\\\": $context.integration.latency }\" } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Resources : Api : Type : AWS::Serverless::Api Properties : DefinitionUri : openapi.yaml StageName : prod # Setup logging for API Gateway AccessLogSetting : DestinationArn : \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\" Format : | { \"stage\" : \"$context.stage\", \"request_id\" : \"$context.requestId\", \"api_id\" : \"$context.apiId\", \"resource_path\" : \"$context.resourcePath\", \"resource_id\" : \"$context.resourceId\", \"http_method\" : \"$context.httpMethod\", \"source_ip\" : \"$context.identity.sourceIp\", \"user-agent\" : \"$context.identity.userAgent\", \"account_id\" : \"$context.identity.accountId\", \"api_key\" : \"$context.identity.apiKey\", \"caller\" : \"$context.identity.caller\", \"user\" : \"$context.identity.user\", \"user_arn\" : \"$context.identity.userArn\", \"integration_latency\": $context.integration.latency } Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 provider : name : aws logs : # Setup logging for API Gateway restApi : accessLogging : true format : | { \"stage\" : \"$context.stage\", \"request_id\" : \"$context.requestId\", \"api_id\" : \"$context.apiId\", \"resource_path\" : \"$context.resourcePath\", \"resource_id\" : \"$context.resourceId\", \"http_method\" : \"$context.httpMethod\", \"source_ip\" : \"$context.identity.sourceIp\", \"user-agent\" : \"$context.identity.userAgent\", \"account_id\" : \"$context.identity.accountId\", \"api_key\" : \"$context.identity.apiKey\", \"caller\" : \"$context.identity.caller\", \"user\" : \"$context.identity.user\", \"user_arn\" : \"$context.identity.userArn\", \"integration_latency\": $context.integration.latency } Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 resource \"aws_api_gateway_rest_api\" \"this\" { body = file ( \"openapi.yaml\" ) } resource \"aws_api_gateway_deployment\" \"this\" { rest_api_id = aws_api_gateway_rest_api.this.id triggers = { redeployment = sha1 ( jsonencode ( aws_api_gateway_rest_api.this.body )) } lifecycle { create_before_destroy = true } } resource \"aws_api_gateway_stage\" \"this\" { deployment_id = aws_api_gateway_deployment.this.id rest_api_id = aws_api_gateway_rest_api.this.id stage_name = \"prod\" # Setup logging for API Gateway access_log_settings { destination_arn = \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\" format = << EOF { \"stage\" : \"$context.stage\" , \"request_id\" : \"$context.requestId\" , \"api_id\" : \"$context.apiId\" , \"resource_path\" : \"$context.resourcePath\" , \"resource_id\" : \"$context.resourceId\" , \"http_method\" : \"$context.httpMethod\" , \"source_ip\" : \"$context.identity.sourceIp\" , \"user-agent\" : \"$context.identity.userAgent\" , \"account_id\" : \"$context.identity.accountId\" , \"api_key\" : \"$context.identity.apiKey\" , \"caller\" : \"$context.identity.caller\" , \"user\" : \"$context.identity.user\" , \"user_arn\" : \"$context.identity.userArn\" , \"integration_latency\" : $ context.integration.latency } EOF } }","title":"Implementations for REST APIs"},{"location":"rules/api_gateway/logging/#implementations-for-http-apis","text":"CDK Remark : this is currently not supported in AWS CDK as an L2 construct at the moment. See this GitHub issue for more details. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import { CfnStage , HttpApi } from '@aws-cdk/aws-apigatewayv2' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myApi = new HttpApi ( scope , 'MyApi' ); // Setup logging for API Gateway using escape hatch. // See https://github.com/aws/aws-cdk/issues/11100 and // https://docs.aws.amazon.com/cdk/latest/guide/cfn_layer.html#cfn_layer_resource // for more information. const defaultStage = myApi . defaultStage . node . defaultChild as CfnStage ; defaultStage . accessLogSettings = { destinationArn : '' , format : JSON.stringify ({ \"stage\" : \"$context.stage\" , \"request_id\" : \"$context.requestId\" , \"api_id\" : \"$context.apiId\" , \"resource_path\" : \"$context.resourcePath\" , \"resource_id\" : \"$context.resourceId\" , \"http_method\" : \"$context.httpMethod\" , \"source_ip\" : \"$context.identity.sourceIp\" , \"user-agent\" : \"$context.identity.userAgent\" , \"account_id\" : \"$context.identity.accountId\" , \"api_key\" : \"$context.identity.apiKey\" , \"caller\" : \"$context.identity.caller\" , \"user\" : \"$context.identity.user\" , \"user_arn\" : \"$context.identity.userArn\" , \"integration_latency\" : $context . integration . latency }), }; } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"Resource\" : { \"Type\" : \"AWS::Serverless::HttpApi\" , \"Properties\" : { \"DefinitionUri\" : \"openapi.yaml\" , \"StageName\" : \"prod\" , // Se tu p loggi n g f or API Ga te way \"AccessLogSettings\" :{ \"DestinationArn\" : \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\" , \"Format\" : \"{ \\\"stage\\\" : \\\"$context.stage\\\", \\\"request_id\\\" : \\\"$context.requestId\\\", \\\"api_id\\\" : \\\"$context.apiId\\\", \\\"resource_path\\\" : \\\"$context.resourcePath\\\", \\\"resource_id\\\" : \\\"$context.resourceId\\\", \\\"http_method\\\" : \\\"$context.httpMethod\\\", \\\"source_ip\\\" : \\\"$context.identity.sourceIp\\\", \\\"user-agent\\\" : \\\"$context.identity.userAgent\\\", \\\"account_id\\\" : \\\"$context.identity.accountId\\\", \\\"api_key\\\" : \\\"$context.identity.apiKey\\\", \\\"caller\\\" : \\\"$context.identity.caller\\\", \\\"user\\\" : \\\"$context.identity.user\\\", \\\"user_arn\\\" : \\\"$context.identity.userArn\\\", \\\"integration_latency\\\": $context.integration.latency }\" } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Resources : Api : Type : AWS::Serverless::HttpApi Properties : DefinitionUri : openapi.yaml StageName : prod # Setup logging for API Gateway AccessLogSettings : DestinationArn : \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\" Format : | { \"stage\" : \"$context.stage\", \"request_id\" : \"$context.requestId\", \"api_id\" : \"$context.apiId\", \"resource_path\" : \"$context.resourcePath\", \"resource_id\" : \"$context.resourceId\", \"http_method\" : \"$context.httpMethod\", \"source_ip\" : \"$context.identity.sourceIp\", \"user-agent\" : \"$context.identity.userAgent\", \"account_id\" : \"$context.identity.accountId\", \"api_key\" : \"$context.identity.apiKey\", \"caller\" : \"$context.identity.caller\", \"user\" : \"$context.identity.user\", \"user_arn\" : \"$context.identity.userArn\", \"integration_latency\": $context.integration.latency } Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 provider : name : aws logs : httpApi : format : | { \"stage\" : \"$context.stage\", \"request_id\" : \"$context.requestId\", \"api_id\" : \"$context.apiId\", \"resource_path\" : \"$context.resourcePath\", \"resource_id\" : \"$context.resourceId\", \"http_method\" : \"$context.httpMethod\", \"source_ip\" : \"$context.identity.sourceIp\", \"user-agent\" : \"$context.identity.userAgent\", \"account_id\" : \"$context.identity.accountId\", \"api_key\" : \"$context.identity.apiKey\", \"caller\" : \"$context.identity.caller\", \"user\" : \"$context.identity.user\", \"user_arn\" : \"$context.identity.userArn\", \"integration_latency\": $context.integration.latency } Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 resource \"aws_apigatewayv2_api\" \"this\" { name = \"my-api\" protocol_type = \"HTTP\" body = file ( \"openapi.yaml\" ) } resource \"aws_apigatewayv2_stage\" \"this\" { api_id = aws_apigatewayv2_api.this.id name = \"prod\" # Setup logging for API Gateway access_log_settings { destination_arn = \"arn:aws:logs:eu-west-1:123456789012:log-group:my-log-group\" format = << EOF { \"stage\" : \"$context.stage\" , \"request_id\" : \"$context.requestId\" , \"api_id\" : \"$context.apiId\" , \"resource_path\" : \"$context.resourcePath\" , \"resource_id\" : \"$context.resourceId\" , \"http_method\" : \"$context.httpMethod\" , \"source_ip\" : \"$context.identity.sourceIp\" , \"user-agent\" : \"$context.identity.userAgent\" , \"account_id\" : \"$context.identity.accountId\" , \"api_key\" : \"$context.identity.apiKey\" , \"caller\" : \"$context.identity.caller\" , \"user\" : \"$context.identity.user\" , \"user_arn\" : \"$context.identity.userArn\" , \"integration_latency\" : $ context.integration.latency } EOF } }","title":"Implementations for HTTP APIs"},{"location":"rules/api_gateway/logging/#see-also","text":"Serverless Lens: Centralized and structured logging Monitoring REST APIs Monitoring your HTTP API Monitoring WebSocket APIs","title":"See also"},{"location":"rules/api_gateway/structured_logging/","text":"API Gateway Structured Logging \u00b6 Level : Warning Initial version : 0.1.3 cfn-lint : WS2001 tflint (REST) : aws_api_gateway_stage_structured_logging tflint (HTTP) : aws_apigatewayv2_stage_structured_logging You can customize the log format that Amazon API Gateway uses to send logs. Structured logging makes it easier to derive queries to answer arbitrary questions about the health of your application. Why is this a warning? \u00b6 The rule in serverless-rules only checks if the structured log is JSON-formatted. While CloudWatch Logs Insights will automatically discover fields in JSON log entries, you can use the parse command to parse custom log entries to extract fields from custom format. Implementations \u00b6 See the implementations for Logging on API Gateway . See also \u00b6 Serverless Lens: Centralized and structured logging Monitoring REST APIs Monitoring your HTTP API Monitoring WebSocket APIs Amazon CloudWatch Logs: Supported Logs and Discovered Fields Amazon CloudWatch Logs: Logs Insights Query Syntax","title":"API Gateway Structured Logging"},{"location":"rules/api_gateway/structured_logging/#api-gateway-structured-logging","text":"Level : Warning Initial version : 0.1.3 cfn-lint : WS2001 tflint (REST) : aws_api_gateway_stage_structured_logging tflint (HTTP) : aws_apigatewayv2_stage_structured_logging You can customize the log format that Amazon API Gateway uses to send logs. Structured logging makes it easier to derive queries to answer arbitrary questions about the health of your application.","title":"API Gateway Structured Logging"},{"location":"rules/api_gateway/structured_logging/#why-is-this-a-warning","text":"The rule in serverless-rules only checks if the structured log is JSON-formatted. While CloudWatch Logs Insights will automatically discover fields in JSON log entries, you can use the parse command to parse custom log entries to extract fields from custom format.","title":"Why is this a warning?"},{"location":"rules/api_gateway/structured_logging/#implementations","text":"See the implementations for Logging on API Gateway .","title":"Implementations"},{"location":"rules/api_gateway/structured_logging/#see-also","text":"Serverless Lens: Centralized and structured logging Monitoring REST APIs Monitoring your HTTP API Monitoring WebSocket APIs Amazon CloudWatch Logs: Supported Logs and Discovered Fields Amazon CloudWatch Logs: Logs Insights Query Syntax","title":"See also"},{"location":"rules/api_gateway/tracing/","text":"API Gateway Tracing \u00b6 Level : Warning Initial version : 0.1.3 cfn-lint : WS2002 tflint (REST) : aws_apigateway_stage_tracing_rule tflint (HTTP) : Not supported Amazon API Gateway can emit traces to AWS X-Ray, which enable visualizing service maps for faster troubleshooting. Implementations for REST APIs \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { RestApi } from '@aws-cdk/aws-apigateway' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myApi = new RestApi ( scope , 'MyApi' , { // Enable tracing on API Gateway deployOptions : { tracingEnabled : true , }, } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"Resources\" : { \"Api\" : { \"Type\" : \"AWS::Serverless::Api\" , \"Properties\" : { \"DefinitionUri\" : \"openapi.yaml\" , \"StageName\" : \"prod\" , // E na ble tra ci n g o n API Ga te way \"TracingEnabled\" : true } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 Resources : Api : Type : AWS::Serverless::Api Properties : DefinitionUri : openapi.yaml StageName : prod # Enable tracing on API Gateway TracingEnabled : true Serverless Framework 1 2 3 4 5 provider : name : aws # Enable tracing on API Gateway tracing : apiGateway : true Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 resource \"aws_api_gateway_rest_api\" \"this\" { body = file ( \"openapi.yaml\" ) } resource \"aws_api_gateway_deployment\" \"this\" { rest_api_id = aws_api_gateway_rest_api.this.id triggers = { redeployment = sha1 ( jsonencode ( aws_api_gateway_rest_api.this.body )) } lifecycle { create_before_destroy = true } } resource \"aws_api_gateway_stage\" \"this\" { deployment_id = aws_api_gateway_deployment.this.id rest_api_id = aws_api_gateway_rest_api.this.id stage_name = \"prod\" # Enable tracing on API Gateway xray_tracing_enabled = true } Implementations for HTTP APIs \u00b6 Remark : HTTP APIs do not support tracing at the moment. Why is this a warning? \u00b6 You might use third party solutions for monitoring serverless applications. If this is the case, enabling tracing for API Gateway might be optional. Refer to the documentation of your monitoring solutions to see if you should enable AWS X-Ray tracing or not. See also \u00b6 Serverless Lens: Distributed Tracing Tracing user requests to REST APIs using X-Ray","title":"API Gateway Tracing"},{"location":"rules/api_gateway/tracing/#api-gateway-tracing","text":"Level : Warning Initial version : 0.1.3 cfn-lint : WS2002 tflint (REST) : aws_apigateway_stage_tracing_rule tflint (HTTP) : Not supported Amazon API Gateway can emit traces to AWS X-Ray, which enable visualizing service maps for faster troubleshooting.","title":"API Gateway Tracing"},{"location":"rules/api_gateway/tracing/#implementations-for-rest-apis","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { RestApi } from '@aws-cdk/aws-apigateway' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myApi = new RestApi ( scope , 'MyApi' , { // Enable tracing on API Gateway deployOptions : { tracingEnabled : true , }, } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"Resources\" : { \"Api\" : { \"Type\" : \"AWS::Serverless::Api\" , \"Properties\" : { \"DefinitionUri\" : \"openapi.yaml\" , \"StageName\" : \"prod\" , // E na ble tra ci n g o n API Ga te way \"TracingEnabled\" : true } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 Resources : Api : Type : AWS::Serverless::Api Properties : DefinitionUri : openapi.yaml StageName : prod # Enable tracing on API Gateway TracingEnabled : true Serverless Framework 1 2 3 4 5 provider : name : aws # Enable tracing on API Gateway tracing : apiGateway : true Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 resource \"aws_api_gateway_rest_api\" \"this\" { body = file ( \"openapi.yaml\" ) } resource \"aws_api_gateway_deployment\" \"this\" { rest_api_id = aws_api_gateway_rest_api.this.id triggers = { redeployment = sha1 ( jsonencode ( aws_api_gateway_rest_api.this.body )) } lifecycle { create_before_destroy = true } } resource \"aws_api_gateway_stage\" \"this\" { deployment_id = aws_api_gateway_deployment.this.id rest_api_id = aws_api_gateway_rest_api.this.id stage_name = \"prod\" # Enable tracing on API Gateway xray_tracing_enabled = true }","title":"Implementations for REST APIs"},{"location":"rules/api_gateway/tracing/#implementations-for-http-apis","text":"Remark : HTTP APIs do not support tracing at the moment.","title":"Implementations for HTTP APIs"},{"location":"rules/api_gateway/tracing/#why-is-this-a-warning","text":"You might use third party solutions for monitoring serverless applications. If this is the case, enabling tracing for API Gateway might be optional. Refer to the documentation of your monitoring solutions to see if you should enable AWS X-Ray tracing or not.","title":"Why is this a warning?"},{"location":"rules/api_gateway/tracing/#see-also","text":"Serverless Lens: Distributed Tracing Tracing user requests to REST APIs using X-Ray","title":"See also"},{"location":"rules/appsync/tracing/","text":"AppSync Tracing \u00b6 Level : Warning Initial version : 0.1.3 cfn-lint : WS3000 tflint : aws_appsync_graphql_api_tracing_rule AWS AppSync can emit traces to AWS X-Ray, which enables visualizing service maps for faster troubleshooting. Why is this a warning? \u00b6 You might use third party solutions for monitoring serverless applications. If this is the case, enabling tracing for AppSync APIs might be optional. Refer to the documentation of your monitoring solutions to see if you should enable AWS X-Ray tracing or not. Implementations \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { GraphqlApi } from '@aws-cdk/aws-appsync' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myApi = new GraphqlApi ( scope , 'MyApi' , { name : 'my-api' , // Enable active tracing xrayEnabled : true , } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"Resources\" : { \"GraphQLApi\" : { \"Type\" : \"AWS::AppSync::GraphQLApi\" , \"Properties\" : { \"Name\" : \"api\" , \"AuthenticationType\" : \"AWS_IAM\" , // E na ble ac t ive tra ci n g \"XrayEnabled\" : true } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 Resources : GraphQLApi : Type : AWS::AppSync::GraphQLApi Properties : Name : api AuthenticationType : AWS_IAM # Enable active tracing XrayEnabled : true Serverless Framework 1 2 3 4 5 6 7 8 9 10 resources : Resources : GraphQLApi : Type : AWS::AppSync::GraphQLApi Properties : Name : api AuthenticationType : AWS_IAM # Enable active tracing XrayEnabled : true Terraform 1 2 3 4 5 6 7 resource \"aws_appsync_graphql_api\" \"this\" { name = \"api\" authentication_type = \"AWS_IAM\" # Enable active tracing xray_enabled = true } See also \u00b6 Serverless Lens: Distributed Tracing Tracing with AWS X-Ray","title":"AppSync Tracing"},{"location":"rules/appsync/tracing/#appsync-tracing","text":"Level : Warning Initial version : 0.1.3 cfn-lint : WS3000 tflint : aws_appsync_graphql_api_tracing_rule AWS AppSync can emit traces to AWS X-Ray, which enables visualizing service maps for faster troubleshooting.","title":"AppSync Tracing"},{"location":"rules/appsync/tracing/#why-is-this-a-warning","text":"You might use third party solutions for monitoring serverless applications. If this is the case, enabling tracing for AppSync APIs might be optional. Refer to the documentation of your monitoring solutions to see if you should enable AWS X-Ray tracing or not.","title":"Why is this a warning?"},{"location":"rules/appsync/tracing/#implementations","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { GraphqlApi } from '@aws-cdk/aws-appsync' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myApi = new GraphqlApi ( scope , 'MyApi' , { name : 'my-api' , // Enable active tracing xrayEnabled : true , } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"Resources\" : { \"GraphQLApi\" : { \"Type\" : \"AWS::AppSync::GraphQLApi\" , \"Properties\" : { \"Name\" : \"api\" , \"AuthenticationType\" : \"AWS_IAM\" , // E na ble ac t ive tra ci n g \"XrayEnabled\" : true } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 Resources : GraphQLApi : Type : AWS::AppSync::GraphQLApi Properties : Name : api AuthenticationType : AWS_IAM # Enable active tracing XrayEnabled : true Serverless Framework 1 2 3 4 5 6 7 8 9 10 resources : Resources : GraphQLApi : Type : AWS::AppSync::GraphQLApi Properties : Name : api AuthenticationType : AWS_IAM # Enable active tracing XrayEnabled : true Terraform 1 2 3 4 5 6 7 resource \"aws_appsync_graphql_api\" \"this\" { name = \"api\" authentication_type = \"AWS_IAM\" # Enable active tracing xray_enabled = true }","title":"Implementations"},{"location":"rules/appsync/tracing/#see-also","text":"Serverless Lens: Distributed Tracing Tracing with AWS X-Ray","title":"See also"},{"location":"rules/eventbridge/rule_without_dlq/","text":"EventBridge Rule without DLQ \u00b6 Level : Error Initial version : 0.1.3 cfn-lint : ES4000 tflint : aws_cloudwatch_event_target_no_dlq Sometimes, an event isn't successfully delivered to the target(s) specified in a rule. By default, EventBridge will retry for 24 hours and up to 185 times, but you can customize the retry policy. If EventBridge cannot deliver an event after all its retries, it can send it to a dead-letter queue. You can then inspect the event and remediate the underlying issue. Implementations \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import { Function } from '@aws-cdk/aws-lambda' ; import { Rule } from '@aws-cdk/aws-events' ; import * as targets from '@aws-cdk/aws-events-targets' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , } ); const myRule = new Rule ( scope , 'MyRule' , { eventPattern : { source : [ 'my-source' ], } } ); myRule . addTarget ( new targets . LambdaFunction ( myfunction , // Add a DLQ to the 'myFunction' target { deadLetterQueue : myQueue , } )); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"Resources\" : { \"MyRule\" : { \"Type\" : \"AWS::Events::Rule\" , \"Properties\" : { \"EventBusName\" : \"default\" , \"EventPattern\" : \"{\\\"source\\\": [\\\"my-source\\\"]}\" , \"Targets\" : [{ \"Id\" : \"MyFunction\" , \"Arn\" : \"arn:aws:lambda:us-east-1:111122223333:function:MyFunction\" , // Add a DLQ t o t he 'MyFu n c t io n ' tar ge t \"DeadLetterConfig\" : { \"Arn\" : \"arn:aws:sqs:us-east-1:111122223333:dlq\" } }] } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Resources : MyRule : Type : AWS::Events::Rule Properties : EventBusName : default EventPattern : | { \"source\": [\"my-source\"] } Targets : - Id : MyFunction Arn : arn:aws:lambda:us-east-1:111122223333:function:MyFunction # Add a DLQ to the 'MyFunction' target DeadLetterConfig : Arn : arn:aws:sqs:us-east-1:111122223333:dlq Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 resources : Resources : MyRule : Type : AWS::Events::Rule Properties : EventBusName : default EventPattern : | { \"source\": [\"my-source\"] } Targets : - Id : MyFunction Arn : arn:aws:lambda:us-east-1:111122223333:function:MyFunction # Add a DLQ to the 'MyFunction' target DeadLetterConfig : Arn : arn:aws:sqs:us-east-1:111122223333:dlq Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 resource \"aws_cloudwatch_event_rule\" \"this\" { event_pattern = << EOF { \"source\" : [ \"my-source\" ] } EOF } resource \"aws_cloudwatch_event_target\" \"this\" { rule = aws_cloudwatch_event_rule.this.name target_id = \"MyFunction\" arn = \"arn:aws:lambda:us-east-1:111122223333:function:MyFunction\" # Add a DLQ to the 'MyFunction' target dead_letter_config { arn = \"arn:aws:sqs:us-east-1:111122223333:dlq\" } } See also \u00b6 Event retry policy and using dead-letter queues","title":"EventBridge Rule without DLQ"},{"location":"rules/eventbridge/rule_without_dlq/#eventbridge-rule-without-dlq","text":"Level : Error Initial version : 0.1.3 cfn-lint : ES4000 tflint : aws_cloudwatch_event_target_no_dlq Sometimes, an event isn't successfully delivered to the target(s) specified in a rule. By default, EventBridge will retry for 24 hours and up to 185 times, but you can customize the retry policy. If EventBridge cannot deliver an event after all its retries, it can send it to a dead-letter queue. You can then inspect the event and remediate the underlying issue.","title":"EventBridge Rule without DLQ"},{"location":"rules/eventbridge/rule_without_dlq/#implementations","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import { Function } from '@aws-cdk/aws-lambda' ; import { Rule } from '@aws-cdk/aws-events' ; import * as targets from '@aws-cdk/aws-events-targets' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , } ); const myRule = new Rule ( scope , 'MyRule' , { eventPattern : { source : [ 'my-source' ], } } ); myRule . addTarget ( new targets . LambdaFunction ( myfunction , // Add a DLQ to the 'myFunction' target { deadLetterQueue : myQueue , } )); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"Resources\" : { \"MyRule\" : { \"Type\" : \"AWS::Events::Rule\" , \"Properties\" : { \"EventBusName\" : \"default\" , \"EventPattern\" : \"{\\\"source\\\": [\\\"my-source\\\"]}\" , \"Targets\" : [{ \"Id\" : \"MyFunction\" , \"Arn\" : \"arn:aws:lambda:us-east-1:111122223333:function:MyFunction\" , // Add a DLQ t o t he 'MyFu n c t io n ' tar ge t \"DeadLetterConfig\" : { \"Arn\" : \"arn:aws:sqs:us-east-1:111122223333:dlq\" } }] } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Resources : MyRule : Type : AWS::Events::Rule Properties : EventBusName : default EventPattern : | { \"source\": [\"my-source\"] } Targets : - Id : MyFunction Arn : arn:aws:lambda:us-east-1:111122223333:function:MyFunction # Add a DLQ to the 'MyFunction' target DeadLetterConfig : Arn : arn:aws:sqs:us-east-1:111122223333:dlq Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 resources : Resources : MyRule : Type : AWS::Events::Rule Properties : EventBusName : default EventPattern : | { \"source\": [\"my-source\"] } Targets : - Id : MyFunction Arn : arn:aws:lambda:us-east-1:111122223333:function:MyFunction # Add a DLQ to the 'MyFunction' target DeadLetterConfig : Arn : arn:aws:sqs:us-east-1:111122223333:dlq Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 resource \"aws_cloudwatch_event_rule\" \"this\" { event_pattern = << EOF { \"source\" : [ \"my-source\" ] } EOF } resource \"aws_cloudwatch_event_target\" \"this\" { rule = aws_cloudwatch_event_rule.this.name target_id = \"MyFunction\" arn = \"arn:aws:lambda:us-east-1:111122223333:function:MyFunction\" # Add a DLQ to the 'MyFunction' target dead_letter_config { arn = \"arn:aws:sqs:us-east-1:111122223333:dlq\" } }","title":"Implementations"},{"location":"rules/eventbridge/rule_without_dlq/#see-also","text":"Event retry policy and using dead-letter queues","title":"See also"},{"location":"rules/lambda/async_failure_destination/","text":"Lambda Async Failure Destination \u00b6 Level : Error Initial version : 0.1.8 cfn-lint : ES1007 tflint : aws_lambda_event_invoke_config_async_on_failure Several AWS services, such as Amazon S3, Amazon SNS, or Amazon EventBridge, invoke Lambda functions asynchronously to process events. When you invoke a function asynchronously, you don't wait for a response from the function code. You hand off the event to Lambda and Lambda handles the rest. When an asynchronous calls fail, they should be captured and retried whenever possible. For this purpose, you can set a destination where Lambda will send events for successful or failed invocations. Matching function name between resources This rule works by comparing Lambda Permission resources with Lambda Event Invoke Config resources. For this rule to work correctly, you must set the function name on both resources in the exact same way. For example, in CloudFormation, if you use the Fn::Ref intrinsic function to refer to your Lambda function on both resources, this rule will work normally. If you use Fn::Ref on one, and Fn::Join on another, this rule will not work. Here are some examples of valid implementation in CloudFormation: With Fn::Ref 1 2 3 4 5 6 7 8 9 10 11 12 Resources : Permission : Type : AWS::Lambda::Permission Properties : # Other properties omitted FunctionName : !Ref MyFunction EventInvokeConfig : Type : AWS::Lambda::EventInvokeConfig Properties : # Other properties omitted FunctionName : !Ref MyFunction With Fn::Sub 1 2 3 4 5 6 7 8 9 10 11 12 Resources : Permission : Type : AWS::Lambda::Permission Properties : # Other properties omitted FunctionName : !Sub \"arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${MyFunction}\" EventInvokeConfig : Type : AWS::Lambda::EventInvokeConfig Properties : # Other properties omitted FunctionName : !Sub \"arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${MyFunction}\" With a static value 1 2 3 4 5 6 7 8 9 10 11 12 Resources : Permission : Type : AWS::Lambda::Permission Properties : # Other properties omitted FunctionName : my-lambda-function EventInvokeConfig : Type : AWS::Lambda::EventInvokeConfig Properties : # Other properties omitted FunctionName : my-lambda-function By comparison, this implementation will return an error: With mixed references 1 2 3 4 5 6 7 8 9 10 11 12 Resources : Permission : Type : AWS::Lambda::Permission Properties : # Other properties omitted FunctionName : !Ref MyFunction EventInvokeConfig : Type : AWS::Lambda::EventInvokeConfig Properties : # Other properties omitted FunctionName : my-lambda-function Implementations \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import { Code , Function , Runtime } from '@aws-cdk/aws-lambda' ; import { SnsEventSource } from '@aws-cdk/aws-lambda-event-sources' ; import { SqsDestination } from '@aws-cdk/aws-lambda-destinations' ; import { Topic } from '@aws-cdk/aws-sns' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myTopic = new Topic ( scope , 'MyTopic' , ); const myDLQ = new Queue ( scope , 'MyDLQ' , ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , onFailure : new SqsDestination ( myDLQ ), } ); // SNS will trigger the function asynchronously myFunction . addEventSource ( new SnsEventSource ( myTopic )); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 { \"Resources\" : { \"SNSFunction\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { \"CodeUri\" : \".\" , // SNS will tr igger t he fun c t io n asy n chro n ously \"Events\" : { \"SNS\" : { \"Type\" : \"SNS\" , \"Properties\" : { \"Topic\" : \"my-sns-topic\" } } }, // Co nf igure a fa ilure des t i nat io n f or t he fun c t io n \"EventInvokeConfig\" : { \"DestinationConfig\" : { \"OnFailure\" : { \"Type\" : \"SQS\" , \"Destination\" : \"arn:aws:sqs:us-east-1:111122223333:my-dlq\" } } } } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 SNSFunction : Type : AWS::Serverless::Function Properties : CodeUri : . # SNS will trigger the function asynchronously Events : SNS : Type : SNS Properties : Topic : my-sns-topic # Configure a failure destination for the function EventInvokeConfig : DestinationConfig : OnFailure : Type : SQS Destination : arn:aws:sqs:us-east-1:111122223333:my-dlq Serverless Framework 1 2 3 4 5 6 7 8 9 10 functions : hello : handler : main.handler # SNS will trigger the function asynchronously events : - sns : topicName : my-sns-topic # Configure a failure destination for the function destinations : onFailure : arn:aws:sqs:us-east-1:111122223333:my-dlq Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" runtime = \"python3.8\" handler = \"main.handler\" filename = \"function.zip\" } resource \"aws_lambda_permission\" \"this\" { action = \"lambda:InvokeFunction\" function_name = aws_lambda_function.this.function_name # Grants the permission to SNS to invoke this function # SNS will trigger the function asynchronously principal = \"sns.amazonaws.com\" } resource \"aws_lambda_function_event_invoke_config\" \"example\" { function_name = aws_lambda_alias.example.function_name # Configure a failure destination for the function destination_config { on_failure { destination = \"arn:aws:sqs:us-east-1:111122223333:my-dlq\" } } } See also \u00b6 Asynchronous invocation Serverless Lens: Failure Management CloudFormation : AWS::Lambda::EventInvokeConfig Terraform : aws_lambda_function_event_invoke_config","title":"Lambda Async Failure Destination"},{"location":"rules/lambda/async_failure_destination/#lambda-async-failure-destination","text":"Level : Error Initial version : 0.1.8 cfn-lint : ES1007 tflint : aws_lambda_event_invoke_config_async_on_failure Several AWS services, such as Amazon S3, Amazon SNS, or Amazon EventBridge, invoke Lambda functions asynchronously to process events. When you invoke a function asynchronously, you don't wait for a response from the function code. You hand off the event to Lambda and Lambda handles the rest. When an asynchronous calls fail, they should be captured and retried whenever possible. For this purpose, you can set a destination where Lambda will send events for successful or failed invocations. Matching function name between resources This rule works by comparing Lambda Permission resources with Lambda Event Invoke Config resources. For this rule to work correctly, you must set the function name on both resources in the exact same way. For example, in CloudFormation, if you use the Fn::Ref intrinsic function to refer to your Lambda function on both resources, this rule will work normally. If you use Fn::Ref on one, and Fn::Join on another, this rule will not work. Here are some examples of valid implementation in CloudFormation: With Fn::Ref 1 2 3 4 5 6 7 8 9 10 11 12 Resources : Permission : Type : AWS::Lambda::Permission Properties : # Other properties omitted FunctionName : !Ref MyFunction EventInvokeConfig : Type : AWS::Lambda::EventInvokeConfig Properties : # Other properties omitted FunctionName : !Ref MyFunction With Fn::Sub 1 2 3 4 5 6 7 8 9 10 11 12 Resources : Permission : Type : AWS::Lambda::Permission Properties : # Other properties omitted FunctionName : !Sub \"arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${MyFunction}\" EventInvokeConfig : Type : AWS::Lambda::EventInvokeConfig Properties : # Other properties omitted FunctionName : !Sub \"arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${MyFunction}\" With a static value 1 2 3 4 5 6 7 8 9 10 11 12 Resources : Permission : Type : AWS::Lambda::Permission Properties : # Other properties omitted FunctionName : my-lambda-function EventInvokeConfig : Type : AWS::Lambda::EventInvokeConfig Properties : # Other properties omitted FunctionName : my-lambda-function By comparison, this implementation will return an error: With mixed references 1 2 3 4 5 6 7 8 9 10 11 12 Resources : Permission : Type : AWS::Lambda::Permission Properties : # Other properties omitted FunctionName : !Ref MyFunction EventInvokeConfig : Type : AWS::Lambda::EventInvokeConfig Properties : # Other properties omitted FunctionName : my-lambda-function","title":"Lambda Async Failure Destination"},{"location":"rules/lambda/async_failure_destination/#implementations","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import { Code , Function , Runtime } from '@aws-cdk/aws-lambda' ; import { SnsEventSource } from '@aws-cdk/aws-lambda-event-sources' ; import { SqsDestination } from '@aws-cdk/aws-lambda-destinations' ; import { Topic } from '@aws-cdk/aws-sns' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myTopic = new Topic ( scope , 'MyTopic' , ); const myDLQ = new Queue ( scope , 'MyDLQ' , ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , onFailure : new SqsDestination ( myDLQ ), } ); // SNS will trigger the function asynchronously myFunction . addEventSource ( new SnsEventSource ( myTopic )); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 { \"Resources\" : { \"SNSFunction\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { \"CodeUri\" : \".\" , // SNS will tr igger t he fun c t io n asy n chro n ously \"Events\" : { \"SNS\" : { \"Type\" : \"SNS\" , \"Properties\" : { \"Topic\" : \"my-sns-topic\" } } }, // Co nf igure a fa ilure des t i nat io n f or t he fun c t io n \"EventInvokeConfig\" : { \"DestinationConfig\" : { \"OnFailure\" : { \"Type\" : \"SQS\" , \"Destination\" : \"arn:aws:sqs:us-east-1:111122223333:my-dlq\" } } } } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 SNSFunction : Type : AWS::Serverless::Function Properties : CodeUri : . # SNS will trigger the function asynchronously Events : SNS : Type : SNS Properties : Topic : my-sns-topic # Configure a failure destination for the function EventInvokeConfig : DestinationConfig : OnFailure : Type : SQS Destination : arn:aws:sqs:us-east-1:111122223333:my-dlq Serverless Framework 1 2 3 4 5 6 7 8 9 10 functions : hello : handler : main.handler # SNS will trigger the function asynchronously events : - sns : topicName : my-sns-topic # Configure a failure destination for the function destinations : onFailure : arn:aws:sqs:us-east-1:111122223333:my-dlq Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" runtime = \"python3.8\" handler = \"main.handler\" filename = \"function.zip\" } resource \"aws_lambda_permission\" \"this\" { action = \"lambda:InvokeFunction\" function_name = aws_lambda_function.this.function_name # Grants the permission to SNS to invoke this function # SNS will trigger the function asynchronously principal = \"sns.amazonaws.com\" } resource \"aws_lambda_function_event_invoke_config\" \"example\" { function_name = aws_lambda_alias.example.function_name # Configure a failure destination for the function destination_config { on_failure { destination = \"arn:aws:sqs:us-east-1:111122223333:my-dlq\" } } }","title":"Implementations"},{"location":"rules/lambda/async_failure_destination/#see-also","text":"Asynchronous invocation Serverless Lens: Failure Management CloudFormation : AWS::Lambda::EventInvokeConfig Terraform : aws_lambda_function_event_invoke_config","title":"See also"},{"location":"rules/lambda/default_memory_size/","text":"Lambda Default Memory Size \u00b6 Level : Error Initial version : 0.1.8 cfn-lint : ES1005 tflint : aws_lambda_function_default_memory Lambda allocates CPU power in proportion to the amount of memory configured. By default, your functions have 128 MB of memory allocated. You can increase that value up to 10 GB. With more CPU resources, your Lambda function's duration might decrease. You can use tools such as AWS Lambda Power Tuning to test your function at different memory settings to find the one that matches your cost and performance requirements the best. Implementations \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { Code , Function , Runtime } from '@aws-cdk/aws-lambda' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , // Change the function memory size memorySize : 2048 , } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"Resources\" : { \"MyFunction\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { // Required proper t ies \"CodeUri\" : \".\" , \"Runtime\" : \"python3.8\" , \"Handler\" : \"main.handler\" , // Cha n ge t he fun c t io n memory size \"MemorySize\" : 2048 } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 Resources : MyFunction : Type : AWS::Serverless::Function Properties : # Required properties CodeUri : . Runtime : python3.8 Handler : main.handler # Change the function memory size MemorySize : 2048 Serverless Framework 1 2 3 4 5 6 7 8 9 10 provider : name : aws # Change the memory size across all functions memorySize : 2048 functions : hello : handler : handler.hello # Change the memory size for one function memorySize : 512 Terraform 1 2 3 4 5 6 7 8 9 resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" runtime = \"python3.8\" handler = \"main.handler\" filename = \"function.zip\" # Change the default memory size value memory_size = 2048 } See also \u00b6 Configuring Lambda function memory Serverless Lens: Optimize AWS Lambda Power Tuning CloudFormation : AWS::Lambda::Function Terraform : aws_lambda_function","title":"Lambda Default Memory Size"},{"location":"rules/lambda/default_memory_size/#lambda-default-memory-size","text":"Level : Error Initial version : 0.1.8 cfn-lint : ES1005 tflint : aws_lambda_function_default_memory Lambda allocates CPU power in proportion to the amount of memory configured. By default, your functions have 128 MB of memory allocated. You can increase that value up to 10 GB. With more CPU resources, your Lambda function's duration might decrease. You can use tools such as AWS Lambda Power Tuning to test your function at different memory settings to find the one that matches your cost and performance requirements the best.","title":"Lambda Default Memory Size"},{"location":"rules/lambda/default_memory_size/#implementations","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { Code , Function , Runtime } from '@aws-cdk/aws-lambda' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , // Change the function memory size memorySize : 2048 , } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"Resources\" : { \"MyFunction\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { // Required proper t ies \"CodeUri\" : \".\" , \"Runtime\" : \"python3.8\" , \"Handler\" : \"main.handler\" , // Cha n ge t he fun c t io n memory size \"MemorySize\" : 2048 } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 Resources : MyFunction : Type : AWS::Serverless::Function Properties : # Required properties CodeUri : . Runtime : python3.8 Handler : main.handler # Change the function memory size MemorySize : 2048 Serverless Framework 1 2 3 4 5 6 7 8 9 10 provider : name : aws # Change the memory size across all functions memorySize : 2048 functions : hello : handler : handler.hello # Change the memory size for one function memorySize : 512 Terraform 1 2 3 4 5 6 7 8 9 resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" runtime = \"python3.8\" handler = \"main.handler\" filename = \"function.zip\" # Change the default memory size value memory_size = 2048 }","title":"Implementations"},{"location":"rules/lambda/default_memory_size/#see-also","text":"Configuring Lambda function memory Serverless Lens: Optimize AWS Lambda Power Tuning CloudFormation : AWS::Lambda::Function Terraform : aws_lambda_function","title":"See also"},{"location":"rules/lambda/default_timeout/","text":"Lambda Default Timeout \u00b6 Level : Error Initial version : 0.1.8 cfn-lint : ES1006 tflint : aws_lambda_function_default_timeout You can define the timeout value, which restricts the maximum duration of a single invocation of your Lambda functions. If your timeout value is too short, Lambda might terminate invocations prematurely. On the other side, setting the timeout much higher than the average execution may cause functions to execute for longer upon code malfunction, resulting in higher costs and possibly reaching concurrency limits depending on how such functions are invoked. Implementations \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { Code , Function , Runtime } from '@aws-cdk/aws-lambda' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , // Change the function timeout timeout : 10 , } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"Resources\" : { \"MyFunction\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { // Required proper t ies \"CodeUri\" : \".\" , \"Runtime\" : \"python3.8\" , \"Handler\" : \"main.handler\" , // Cha n ge t he fun c t io n t imeou t \"Timeout\" : 10 } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 Resources : MyFunction : Type : AWS::Serverless::Function Properties : # Required properties CodeUri : . Runtime : python3.8 Handler : main.handler # Change the function timeout Timeout : 10 Serverless Framework 1 2 3 4 5 6 7 8 9 10 provider : name : aws # Change the timeout across all functions timeout : 10 functions : hello : handler : handler.hello # Change the timeout for one function timeout : 15 Terraform 1 2 3 4 5 6 7 8 9 resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" runtime = \"python3.8\" handler = \"main.handler\" filename = \"function.zip\" # Change the function timeout timeout = 10 } See also \u00b6 AWS Lambda execution environment Serverless Lens: Optimize CloudFormation : AWS::Lambda::Function Terraform : aws_lambda_function","title":"Lambda Default Timeout"},{"location":"rules/lambda/default_timeout/#lambda-default-timeout","text":"Level : Error Initial version : 0.1.8 cfn-lint : ES1006 tflint : aws_lambda_function_default_timeout You can define the timeout value, which restricts the maximum duration of a single invocation of your Lambda functions. If your timeout value is too short, Lambda might terminate invocations prematurely. On the other side, setting the timeout much higher than the average execution may cause functions to execute for longer upon code malfunction, resulting in higher costs and possibly reaching concurrency limits depending on how such functions are invoked.","title":"Lambda Default Timeout"},{"location":"rules/lambda/default_timeout/#implementations","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { Code , Function , Runtime } from '@aws-cdk/aws-lambda' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , // Change the function timeout timeout : 10 , } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"Resources\" : { \"MyFunction\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { // Required proper t ies \"CodeUri\" : \".\" , \"Runtime\" : \"python3.8\" , \"Handler\" : \"main.handler\" , // Cha n ge t he fun c t io n t imeou t \"Timeout\" : 10 } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 Resources : MyFunction : Type : AWS::Serverless::Function Properties : # Required properties CodeUri : . Runtime : python3.8 Handler : main.handler # Change the function timeout Timeout : 10 Serverless Framework 1 2 3 4 5 6 7 8 9 10 provider : name : aws # Change the timeout across all functions timeout : 10 functions : hello : handler : handler.hello # Change the timeout for one function timeout : 15 Terraform 1 2 3 4 5 6 7 8 9 resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" runtime = \"python3.8\" handler = \"main.handler\" filename = \"function.zip\" # Change the function timeout timeout = 10 }","title":"Implementations"},{"location":"rules/lambda/default_timeout/#see-also","text":"AWS Lambda execution environment Serverless Lens: Optimize CloudFormation : AWS::Lambda::Function Terraform : aws_lambda_function","title":"See also"},{"location":"rules/lambda/end_of_life_runtime/","text":"Lambda End-of-life Runtime \u00b6 Level : Error Initial version : 0.1.7 cfn-lint : E2531 tflint : aws_lambda_function_eol_runtime Managed Lambda runtimes for .zip file archives are built around a combination of operating system, programming language, and software libraries that are subject to maintenance and security updates. When security updates are no longer available for a component of a runtime, Lambda deprecates the runtime. Info This rule is implemented natively in cfn-lint as rule number E2531 . Implementations \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { Code , Function , Runtime } from '@aws-cdk/aws-lambda' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , // Select a runtime that is not deprecated runtime : Runtime.PYTHON_3_8 , } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"Resources\" : { \"MyFunction\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { \"CodeUri\" : \".\" , // Selec t a ru nt ime t ha t is n o t depreca te d \"Runtime\" : \"python3.8\" , \"Handler\" : \"main.handler\" } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 Resources : MyFunction : Type : AWS::Serverless::Function Properties : CodeUri : . # Select a runtime that is not deprecated Runtime : python3.8 Handler : main.handler Serverless Framework 1 2 3 4 5 6 7 8 provider : name : aws # Select a runtime that is not deprecated runtime : nodejs14.x functions : hello : handler : handler.hello Terraform 1 2 3 4 5 6 7 resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" # Select a runtime that is not deprecated runtime = \"python3.8\" handler = \"main.handler\" filename = \"function.zip\" } See also \u00b6 Runtime support policy","title":"Lambda End-of-life Runtime"},{"location":"rules/lambda/end_of_life_runtime/#lambda-end-of-life-runtime","text":"Level : Error Initial version : 0.1.7 cfn-lint : E2531 tflint : aws_lambda_function_eol_runtime Managed Lambda runtimes for .zip file archives are built around a combination of operating system, programming language, and software libraries that are subject to maintenance and security updates. When security updates are no longer available for a component of a runtime, Lambda deprecates the runtime. Info This rule is implemented natively in cfn-lint as rule number E2531 .","title":"Lambda End-of-life Runtime"},{"location":"rules/lambda/end_of_life_runtime/#implementations","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { Code , Function , Runtime } from '@aws-cdk/aws-lambda' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , // Select a runtime that is not deprecated runtime : Runtime.PYTHON_3_8 , } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"Resources\" : { \"MyFunction\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { \"CodeUri\" : \".\" , // Selec t a ru nt ime t ha t is n o t depreca te d \"Runtime\" : \"python3.8\" , \"Handler\" : \"main.handler\" } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 Resources : MyFunction : Type : AWS::Serverless::Function Properties : CodeUri : . # Select a runtime that is not deprecated Runtime : python3.8 Handler : main.handler Serverless Framework 1 2 3 4 5 6 7 8 provider : name : aws # Select a runtime that is not deprecated runtime : nodejs14.x functions : hello : handler : handler.hello Terraform 1 2 3 4 5 6 7 resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" # Select a runtime that is not deprecated runtime = \"python3.8\" handler = \"main.handler\" filename = \"function.zip\" }","title":"Implementations"},{"location":"rules/lambda/end_of_life_runtime/#see-also","text":"Runtime support policy","title":"See also"},{"location":"rules/lambda/eventsourcemapping_failure_destination/","text":"Lambda EventSourceMapping Failure Destination \u00b6 Level : Error Initial version : 0.1.6 cfn-lint : ES1001 tflint : aws_lambda_event_source_mapping_failure_destination An AWS Lambda event source mapping reads from streams and poll-based event sources to invoke your functions. You can configure the event source mapping to send invocation records to another service such as Amazon SNS or Amazon SQS when it discards an event batch. Implementations \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { EventSourceMapping , SqsDlq , StartingPosition } from '@aws-cdk/aws-lambda' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); new EventSourceMapping ( scope , \"MyEventSourceMapping\" , { target : myFunction , eventSourceArn : 'arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream' , startingPosition : StartingPosition.LATEST , onFailure : SqsDlq ( mySqsQueue ), }); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"Resource\" : { \"MyEventSourceMapping\" : { \"Type\" : \"AWS::Lambda::EventSourceMapping\" , \"Properties\" : { // Required proper t ies \"FunctionName\" : \"my-function\" , \"EventSourceArn\" : \"arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream\" , \"StartingPosition\" : \"LATEST\" , // Add a n O n Failure des t i nat io n o n t he eve nt source mappi n g \"DestinationConfig\" : { \"OnFailure\" : { \"Destination\" : \"arn:aws:sqs:us-east-1:111122223333:my-dlq\" } } } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 Resources : MyEventSourceMapping : Type : AWS::Lambda::EventSourceMapping Properties : # Required properties FunctionName : my-function EventSourceArn : arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream StartingPosition : LATEST # Add an OnFailure destination on the event source mapping DestinationConfig : OnFailure : Destination : arn:aws:sqs:us-east-1:111122223333:my-dlq Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 functions : MyFunction : handler : hello.handler resources : Resources : MyEventSourceMapping : Type : AWS::Lambda::EventSourceMapping Properties : # Required properties FunctionName : Fn::Ref : MyFunction EventSourceArn : arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream StartingPosition : LATEST # Add an OnFailure destination on the event source mapping DestinationConfig : OnFailure : Destination : arn:aws:sqs:us-east-1:111122223333:my-dlq Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 resource \"aws_lambda_event_source_mapping\" \"this\" { # Required fields event_source_arn = \"arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream\" function_name = \"my-function\" starting_position = \"LATEST\" # Add an OnFailure destination on the event source mapping destination_config { on_failure { destination_arn = \"arn:aws:sqs:us-east-1:111122223333:my-dlq\" } } } See also \u00b6 AWS Lambda event source mappings CloudFormation : AWS::Lambda::EventSourceMapping Terraform : aws_lambda_event_source_mapping","title":"Lambda EventSourceMapping Failure Destination"},{"location":"rules/lambda/eventsourcemapping_failure_destination/#lambda-eventsourcemapping-failure-destination","text":"Level : Error Initial version : 0.1.6 cfn-lint : ES1001 tflint : aws_lambda_event_source_mapping_failure_destination An AWS Lambda event source mapping reads from streams and poll-based event sources to invoke your functions. You can configure the event source mapping to send invocation records to another service such as Amazon SNS or Amazon SQS when it discards an event batch.","title":"Lambda EventSourceMapping Failure Destination"},{"location":"rules/lambda/eventsourcemapping_failure_destination/#implementations","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { EventSourceMapping , SqsDlq , StartingPosition } from '@aws-cdk/aws-lambda' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); new EventSourceMapping ( scope , \"MyEventSourceMapping\" , { target : myFunction , eventSourceArn : 'arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream' , startingPosition : StartingPosition.LATEST , onFailure : SqsDlq ( mySqsQueue ), }); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"Resource\" : { \"MyEventSourceMapping\" : { \"Type\" : \"AWS::Lambda::EventSourceMapping\" , \"Properties\" : { // Required proper t ies \"FunctionName\" : \"my-function\" , \"EventSourceArn\" : \"arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream\" , \"StartingPosition\" : \"LATEST\" , // Add a n O n Failure des t i nat io n o n t he eve nt source mappi n g \"DestinationConfig\" : { \"OnFailure\" : { \"Destination\" : \"arn:aws:sqs:us-east-1:111122223333:my-dlq\" } } } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 Resources : MyEventSourceMapping : Type : AWS::Lambda::EventSourceMapping Properties : # Required properties FunctionName : my-function EventSourceArn : arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream StartingPosition : LATEST # Add an OnFailure destination on the event source mapping DestinationConfig : OnFailure : Destination : arn:aws:sqs:us-east-1:111122223333:my-dlq Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 functions : MyFunction : handler : hello.handler resources : Resources : MyEventSourceMapping : Type : AWS::Lambda::EventSourceMapping Properties : # Required properties FunctionName : Fn::Ref : MyFunction EventSourceArn : arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream StartingPosition : LATEST # Add an OnFailure destination on the event source mapping DestinationConfig : OnFailure : Destination : arn:aws:sqs:us-east-1:111122223333:my-dlq Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 resource \"aws_lambda_event_source_mapping\" \"this\" { # Required fields event_source_arn = \"arn:aws:dynamodb:us-east-1:111122223333:table/my-table/stream/my-stream\" function_name = \"my-function\" starting_position = \"LATEST\" # Add an OnFailure destination on the event source mapping destination_config { on_failure { destination_arn = \"arn:aws:sqs:us-east-1:111122223333:my-dlq\" } } }","title":"Implementations"},{"location":"rules/lambda/eventsourcemapping_failure_destination/#see-also","text":"AWS Lambda event source mappings CloudFormation : AWS::Lambda::EventSourceMapping Terraform : aws_lambda_event_source_mapping","title":"See also"},{"location":"rules/lambda/log_retention/","text":"Lambda Log Retention \u00b6 Level : Warning Initial version : 0.1.3 cfn-lint : WS1004 tflint : Not implemented By default, CloudWatch log groups created by Lambda functions have an unlimited retention time. For cost optimization purposes, you should set a retention duration on all log groups. For log archival, export and set cost-effective storage classes that best suit your needs. Referencing the function name in the log group This rule works by matching a Lambda function name in the CloudWatch log group name. For CloudFormation, it supports Fn::Join , Fn::Sub , and hard-coding the Lambda function name into the log group name. Here are some examples of valid implementations: With Fn::Join 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Resources : Function : Type : AWS::Serverless::Function Properties : # Omitting other properties LogGroup : Type : AWS::Logs::LogGroup Properties : LogGroupName : Fn::Join : - \"\" - - \"/aws/lambda/\" - !Ref Function RetentionInDays : 7 With Fn::Sub 1 2 3 4 5 6 7 8 9 10 11 Resources : Function : Type : AWS::Serverless::Function Properties : # Omitting other properties LogGroup : Type : AWS::Logs::LogGroup Properties : LogGroupName : !Sub \"/aws/lambda/${Function}\" RetentionInDays : 7 With function name 1 2 3 4 5 6 7 8 9 10 11 12 Resources : Function : Type : AWS::Serverless::Function Properties : # Omitting other properties FunctionName : my_function_name LogGroup : Type : AWS::Logs::LogGroup Properties : LogGroupName : \"/aws/lambda/my_function_name RetentionInDays: 7 Why is this a warning? \u00b6 Since serverless-rules evaluate infrastructure-as-code template, it cannot check if you use a solution that will automatically change the configuration of log groups after the fact. Implementations \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import { Code , Function , Runtime } from '@aws-cdk/aws-lambda' ; import { LogGroup , RetentionDays } from '@aws-cdk/aws-logs' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , } ); // Explicit log group that refers to the Lambda function const myLogGroup = new LogGroup ( scope , 'MyLogGroup' , { logGroupName : `/aws/lambda/ ${ myFunction . functionName } ` , retention : RetentionDays.ONE_WEEK , } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \"Resources\" : { // Lambda fun c t io n \"Function\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { \"CodeUri\" : \".\" , \"Runtime\" : \"python3.8\" , \"Handler\" : \"main.handler\" , \"Tracing\" : \"Active\" } }, // Explici t log group t ha t re fers t o t he Lambda fun c t io n \"LogGroup\" : { \"Type\" : \"AWS::Logs::LogGroup\" , \"Properties\" : { \"LogGroupName\" : { \"Fn::Sub\" : \"/aws/lambda/${Function}\" }, // Explici t re tent io n t ime \"RetentionInDays\" : 7 } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Resources : Function : Type : AWS::Serverless::Function Properties : CodeUri : . Runtime : python3.8 Handler : main.handler Tracing : Active # Explicit log group that refers to the Lambda function LogGroup : Type : AWS::Logs::LogGroup Properties : LogGroupName : !Sub \"/aws/lambda/${Function}\" # Explicit retention time RetentionInDays : 7 Serverless Framework 1 2 3 4 5 6 7 8 9 10 provider : name : aws runtime : python3.8 lambdaHashingVersion : '20201221' # This will automatically create the log group with retention logRetentionInDays : 14 functions : hello : handler : handler.hello Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" handler = \"main.handler\" runtime = \"python3.8\" filename = \"function.zip\" role = \"arn:aws:iam::111122223333:role/my-function-role\" } # Explicit log group resource \"aws_cloudwatch_log_group\" \"this\" { name = \"/aws/lambda/ { aws_lambda_function.this.function_name } # Explicit retention time retention_in_days = 7 } See also \u00b6 Serverless Lens: Logging Ingestion and Storage CloudFormation : AWS::Logs::LogGroup Terraform : aws_cloudwatch_log_group","title":"Lambda Log Retention"},{"location":"rules/lambda/log_retention/#lambda-log-retention","text":"Level : Warning Initial version : 0.1.3 cfn-lint : WS1004 tflint : Not implemented By default, CloudWatch log groups created by Lambda functions have an unlimited retention time. For cost optimization purposes, you should set a retention duration on all log groups. For log archival, export and set cost-effective storage classes that best suit your needs. Referencing the function name in the log group This rule works by matching a Lambda function name in the CloudWatch log group name. For CloudFormation, it supports Fn::Join , Fn::Sub , and hard-coding the Lambda function name into the log group name. Here are some examples of valid implementations: With Fn::Join 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Resources : Function : Type : AWS::Serverless::Function Properties : # Omitting other properties LogGroup : Type : AWS::Logs::LogGroup Properties : LogGroupName : Fn::Join : - \"\" - - \"/aws/lambda/\" - !Ref Function RetentionInDays : 7 With Fn::Sub 1 2 3 4 5 6 7 8 9 10 11 Resources : Function : Type : AWS::Serverless::Function Properties : # Omitting other properties LogGroup : Type : AWS::Logs::LogGroup Properties : LogGroupName : !Sub \"/aws/lambda/${Function}\" RetentionInDays : 7 With function name 1 2 3 4 5 6 7 8 9 10 11 12 Resources : Function : Type : AWS::Serverless::Function Properties : # Omitting other properties FunctionName : my_function_name LogGroup : Type : AWS::Logs::LogGroup Properties : LogGroupName : \"/aws/lambda/my_function_name RetentionInDays: 7","title":"Lambda Log Retention"},{"location":"rules/lambda/log_retention/#why-is-this-a-warning","text":"Since serverless-rules evaluate infrastructure-as-code template, it cannot check if you use a solution that will automatically change the configuration of log groups after the fact.","title":"Why is this a warning?"},{"location":"rules/lambda/log_retention/#implementations","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import { Code , Function , Runtime } from '@aws-cdk/aws-lambda' ; import { LogGroup , RetentionDays } from '@aws-cdk/aws-logs' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , } ); // Explicit log group that refers to the Lambda function const myLogGroup = new LogGroup ( scope , 'MyLogGroup' , { logGroupName : `/aws/lambda/ ${ myFunction . functionName } ` , retention : RetentionDays.ONE_WEEK , } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \"Resources\" : { // Lambda fun c t io n \"Function\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { \"CodeUri\" : \".\" , \"Runtime\" : \"python3.8\" , \"Handler\" : \"main.handler\" , \"Tracing\" : \"Active\" } }, // Explici t log group t ha t re fers t o t he Lambda fun c t io n \"LogGroup\" : { \"Type\" : \"AWS::Logs::LogGroup\" , \"Properties\" : { \"LogGroupName\" : { \"Fn::Sub\" : \"/aws/lambda/${Function}\" }, // Explici t re tent io n t ime \"RetentionInDays\" : 7 } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Resources : Function : Type : AWS::Serverless::Function Properties : CodeUri : . Runtime : python3.8 Handler : main.handler Tracing : Active # Explicit log group that refers to the Lambda function LogGroup : Type : AWS::Logs::LogGroup Properties : LogGroupName : !Sub \"/aws/lambda/${Function}\" # Explicit retention time RetentionInDays : 7 Serverless Framework 1 2 3 4 5 6 7 8 9 10 provider : name : aws runtime : python3.8 lambdaHashingVersion : '20201221' # This will automatically create the log group with retention logRetentionInDays : 14 functions : hello : handler : handler.hello Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" handler = \"main.handler\" runtime = \"python3.8\" filename = \"function.zip\" role = \"arn:aws:iam::111122223333:role/my-function-role\" } # Explicit log group resource \"aws_cloudwatch_log_group\" \"this\" { name = \"/aws/lambda/ { aws_lambda_function.this.function_name } # Explicit retention time retention_in_days = 7 }","title":"Implementations"},{"location":"rules/lambda/log_retention/#see-also","text":"Serverless Lens: Logging Ingestion and Storage CloudFormation : AWS::Logs::LogGroup Terraform : aws_cloudwatch_log_group","title":"See also"},{"location":"rules/lambda/permission_multiple_principals/","text":"Lambda Permission Multiple Principals \u00b6 Level : Warning Initial version : 0.1.3 cfn-lint : WS1002 tflint : aws_lambda_permission_multiple_principals You can use resource-based policies to grant permission to other AWS services to invoke your Lambda functions. Different AWS services usually send different payloads to Lambda functions. If multiple services can invoke the same function, this function needs to handle the different types of payload properly, or this could cause unexpected behavior. In general, it's better to create multiple Lambda functions with different function handlers for each invocation source. Implementations \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { ServicePrincipal } from '@aws-cdk/aws-iam' ; import { Function } from '@aws-cdk/aws-lambda' ; import { SnsEventSource } from '@aws-cdk/aws-lambda-event-sources' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , } ); // This will implicitely grant those SNS topics the permission to invoke // the Lambda function. As both come from SNS, this is a single principal // ('sns.amazonaws.com') and thus will not trigger the rule. myFunction . addEventSource ( new SnsEventSource ( myTopic1 )); myFunction . addEventSource ( new SnsEventSource ( myTopic2 )); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { \"Resources\" : { \"MyFunction\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { \"CodeUri\" : \".\" , \"Runtime\" : \"python3.8\" , \"Handler\" : \"main.handler\" , // This will implici tel y gra nt t hose SNS t opics t he permissio n t o i n voke // t he Lambda fun c t io n . As bo t h come fr om SNS , t his is a si n gle pri n cipal // ('s ns .amazo na ws.com') a n d t hus will n o t tr igger t he rule. \"Events\" : { \"Topic1\" : { \"Type\" : \"SNS\" , \"Properties\" : { \"Topic\" : ar n : aws : s ns : us -e as t -1 : 111122223333 : t opic 1 } } \"Topic2\" : { \"Type\" : \"SNS\" , \"Properties\" : { \"Topic\" : ar n : aws : s ns : us -e as t -1 : 111122223333 : t opic 2 } } } } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Resources : MyFunction : Type : AWS::Serverless::Function Properties : CodeUri : . Runtime : python3.8 Handler : main.handler Tracing : Active # This will implicitely grant those SNS topics the permission to invoke # the Lambda function. As both come from SNS, this is a single principal # ('sns.amazonaws.com') and thus will not trigger the rule. Events : Topic1 : Type : SNS Properties : Topic : arn:aws:sns:us-east-1:111122223333:topic1 Topic2 : Type : SNS Properties : Topic : arn:aws:sns:us-east-1:111122223333:topic2 Serverless Framework 1 2 3 4 5 6 7 8 9 functions : hello : handler : handler.hello # This will implicitely grant those SNS topics the permission to invoke # the Lambda function. As both come from SNS, this is a single principal # ('sns.amazonaws.com') and thus will not trigger the rule. events : - sns : topic1 - sns : topic2 Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 resource \"aws_iam_role\" \"this\" { name = \"my-function-role\" assume_role_policy = data.aws_iam_policy_document.assume.json inline_policy { name = \"FunctionPolicy\" policy = data.aws_iam_policy_document.this.json } } data \"aws_iam_policy_document\" \"assume\" { statement { actions = [ \"sts:AssumeRole\" ] principals { type = \"Service\" identifiers = [ \"lambda.amazonaws.com\" ] } } } data \"aws_iam_policy_document\" \"this\" { statement { # Tightly scoped permissions to just 'dynamodb:Query' # instead of 'dynamodb:*' or '*' actions = [ \"dynamodb:Query\" ] resources = [ \"arn:aws:dynamodb:eu-west-1:111122223333:table/my-table\" ] } } resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" handler = \"main.handler\" runtime = \"python3.8\" filename = \"function.zip\" role = aws_iam_role.this.arn } # Add a Lambda permission for Amazon EventBridge resource \"aws_lambda_permission\" \"this\" { statement_id = \"AllowExecutionFromEventBridge\" action = \"lambda:InvokeFunction\" function_name = aws_lambda_function.this.function_name principal = \"events.amazonaws.com\" } Why is this a warning? \u00b6 You might have a valid reason for invoking a Lambda function from different event sources or AWS services. If this is the case and you know what you are doing, you might ignore this rule. See also \u00b6 Using resource-based policies for AWS Lambda","title":"Lambda Permission Multiple Principals"},{"location":"rules/lambda/permission_multiple_principals/#lambda-permission-multiple-principals","text":"Level : Warning Initial version : 0.1.3 cfn-lint : WS1002 tflint : aws_lambda_permission_multiple_principals You can use resource-based policies to grant permission to other AWS services to invoke your Lambda functions. Different AWS services usually send different payloads to Lambda functions. If multiple services can invoke the same function, this function needs to handle the different types of payload properly, or this could cause unexpected behavior. In general, it's better to create multiple Lambda functions with different function handlers for each invocation source.","title":"Lambda Permission Multiple Principals"},{"location":"rules/lambda/permission_multiple_principals/#implementations","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import { ServicePrincipal } from '@aws-cdk/aws-iam' ; import { Function } from '@aws-cdk/aws-lambda' ; import { SnsEventSource } from '@aws-cdk/aws-lambda-event-sources' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , } ); // This will implicitely grant those SNS topics the permission to invoke // the Lambda function. As both come from SNS, this is a single principal // ('sns.amazonaws.com') and thus will not trigger the rule. myFunction . addEventSource ( new SnsEventSource ( myTopic1 )); myFunction . addEventSource ( new SnsEventSource ( myTopic2 )); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { \"Resources\" : { \"MyFunction\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { \"CodeUri\" : \".\" , \"Runtime\" : \"python3.8\" , \"Handler\" : \"main.handler\" , // This will implici tel y gra nt t hose SNS t opics t he permissio n t o i n voke // t he Lambda fun c t io n . As bo t h come fr om SNS , t his is a si n gle pri n cipal // ('s ns .amazo na ws.com') a n d t hus will n o t tr igger t he rule. \"Events\" : { \"Topic1\" : { \"Type\" : \"SNS\" , \"Properties\" : { \"Topic\" : ar n : aws : s ns : us -e as t -1 : 111122223333 : t opic 1 } } \"Topic2\" : { \"Type\" : \"SNS\" , \"Properties\" : { \"Topic\" : ar n : aws : s ns : us -e as t -1 : 111122223333 : t opic 2 } } } } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Resources : MyFunction : Type : AWS::Serverless::Function Properties : CodeUri : . Runtime : python3.8 Handler : main.handler Tracing : Active # This will implicitely grant those SNS topics the permission to invoke # the Lambda function. As both come from SNS, this is a single principal # ('sns.amazonaws.com') and thus will not trigger the rule. Events : Topic1 : Type : SNS Properties : Topic : arn:aws:sns:us-east-1:111122223333:topic1 Topic2 : Type : SNS Properties : Topic : arn:aws:sns:us-east-1:111122223333:topic2 Serverless Framework 1 2 3 4 5 6 7 8 9 functions : hello : handler : handler.hello # This will implicitely grant those SNS topics the permission to invoke # the Lambda function. As both come from SNS, this is a single principal # ('sns.amazonaws.com') and thus will not trigger the rule. events : - sns : topic1 - sns : topic2 Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 resource \"aws_iam_role\" \"this\" { name = \"my-function-role\" assume_role_policy = data.aws_iam_policy_document.assume.json inline_policy { name = \"FunctionPolicy\" policy = data.aws_iam_policy_document.this.json } } data \"aws_iam_policy_document\" \"assume\" { statement { actions = [ \"sts:AssumeRole\" ] principals { type = \"Service\" identifiers = [ \"lambda.amazonaws.com\" ] } } } data \"aws_iam_policy_document\" \"this\" { statement { # Tightly scoped permissions to just 'dynamodb:Query' # instead of 'dynamodb:*' or '*' actions = [ \"dynamodb:Query\" ] resources = [ \"arn:aws:dynamodb:eu-west-1:111122223333:table/my-table\" ] } } resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" handler = \"main.handler\" runtime = \"python3.8\" filename = \"function.zip\" role = aws_iam_role.this.arn } # Add a Lambda permission for Amazon EventBridge resource \"aws_lambda_permission\" \"this\" { statement_id = \"AllowExecutionFromEventBridge\" action = \"lambda:InvokeFunction\" function_name = aws_lambda_function.this.function_name principal = \"events.amazonaws.com\" }","title":"Implementations"},{"location":"rules/lambda/permission_multiple_principals/#why-is-this-a-warning","text":"You might have a valid reason for invoking a Lambda function from different event sources or AWS services. If this is the case and you know what you are doing, you might ignore this rule.","title":"Why is this a warning?"},{"location":"rules/lambda/permission_multiple_principals/#see-also","text":"Using resource-based policies for AWS Lambda","title":"See also"},{"location":"rules/lambda/star_permissions/","text":"Lambda Star Permissions \u00b6 Level : Warning Initial version : 0.1.3 cfn-lint : WS1003 tflint : Not implemented With Lambda functions, you should follow least-privileged access and only allow the access needed to perform a given operation. Attaching a role with more permissions than necessary can open up your systems for abuse. Why is this a warning? \u00b6 If your Lambda function needs a broad range of permissions, you do not know ahead of time which permissions you will need, and you have evaluated the risks of using broad permissions for this function, you might ignore this rule. Implementations \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import { AttributeType , Table } from '@aws-cdk/aws-dynamodb' ; import { Code , Function , Runtime } from '@aws-cdk/aws-lambda' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myTable = new Table ( scope , 'MyTable' , { partitionKey : { name : 'id' , type : AttributeType . STRING , } }, ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , } ); // Grant read access to the DynamoDB table table . grantReadData ( myFunction ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"Resources\" : { \"MyFunction\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { \"CodeUri\" : \".\" , \"Runtime\" : \"python3.8\" , \"Handler\" : \"main.handler\" , \"Policies\" : [{ \"Version\" : \"2012-10-17\" , \"Statement\" : [{ \"Effect\" : \"Allow\" , // Tigh tl y scoped permissio ns t o jus t 's 3 : Ge t Objec t ' // i nstea d o f 's 3 : *' or '*' \"Action\" : \"s3:GetObject\" , \"Resource\" : \"arn:aws:s3:::my-bucket/*\" }] }] } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Resources : MyFunction : Type : AWS::Serverless::Function Properties : CodeUri : . Runtime : python3.8 Handler : main.handler Policies : - Version : \"2012-10-17\" Statement : - Effect : Allow # Tightly scoped permissions to just 's3:GetObject' # instead of 's3:*' or '*' Action : s3:GetObject Resource : \"arn:aws:s3:::my-bucket/*\" Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 provider : name : aws iam : role : name : my-function-role statements : - Effect : Allow # Tightly scoped permissions to just 's3:GetObject' # instead of 's3:*' or '*' Action : s3:GetObject Resource : \"arn:aws:s3:::my-bucket/*\" functions : hello : handler : handler.hello Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 resource \"aws_iam_role\" \"this\" { name = \"my-function-role\" assume_role_policy = data.aws_iam_policy_document.assume.json inline_policy { name = \"FunctionPolicy\" policy = data.aws_iam_policy_document.this.json } } data \"aws_iam_policy_document\" \"assume\" { statement { actions = [ \"sts:AssumeRole\" ] principals { type = \"Service\" identifiers = [ \"lambda.amazonaws.com\" ] } } } data \"aws_iam_policy_document\" \"this\" { statement { # Tightly scoped permissions to just 'dynamodb:Query' # instead of 'dynamodb:*' or '*' actions = [ \"dynamodb:Query\" ] resources = [ \"arn:aws:dynamodb:eu-west-1:111122223333:table/my-table\" ] } } resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" handler = \"main.handler\" runtime = \"python3.8\" filename = \"function.zip\" role = aws_iam_role.this.arn } See also \u00b6 Serverless Lens: Identity and Access Management AWS Lambda execution role","title":"Lambda Star Permissions"},{"location":"rules/lambda/star_permissions/#lambda-star-permissions","text":"Level : Warning Initial version : 0.1.3 cfn-lint : WS1003 tflint : Not implemented With Lambda functions, you should follow least-privileged access and only allow the access needed to perform a given operation. Attaching a role with more permissions than necessary can open up your systems for abuse.","title":"Lambda Star Permissions"},{"location":"rules/lambda/star_permissions/#why-is-this-a-warning","text":"If your Lambda function needs a broad range of permissions, you do not know ahead of time which permissions you will need, and you have evaluated the risks of using broad permissions for this function, you might ignore this rule.","title":"Why is this a warning?"},{"location":"rules/lambda/star_permissions/#implementations","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import { AttributeType , Table } from '@aws-cdk/aws-dynamodb' ; import { Code , Function , Runtime } from '@aws-cdk/aws-lambda' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myTable = new Table ( scope , 'MyTable' , { partitionKey : { name : 'id' , type : AttributeType . STRING , } }, ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , } ); // Grant read access to the DynamoDB table table . grantReadData ( myFunction ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"Resources\" : { \"MyFunction\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { \"CodeUri\" : \".\" , \"Runtime\" : \"python3.8\" , \"Handler\" : \"main.handler\" , \"Policies\" : [{ \"Version\" : \"2012-10-17\" , \"Statement\" : [{ \"Effect\" : \"Allow\" , // Tigh tl y scoped permissio ns t o jus t 's 3 : Ge t Objec t ' // i nstea d o f 's 3 : *' or '*' \"Action\" : \"s3:GetObject\" , \"Resource\" : \"arn:aws:s3:::my-bucket/*\" }] }] } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Resources : MyFunction : Type : AWS::Serverless::Function Properties : CodeUri : . Runtime : python3.8 Handler : main.handler Policies : - Version : \"2012-10-17\" Statement : - Effect : Allow # Tightly scoped permissions to just 's3:GetObject' # instead of 's3:*' or '*' Action : s3:GetObject Resource : \"arn:aws:s3:::my-bucket/*\" Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 provider : name : aws iam : role : name : my-function-role statements : - Effect : Allow # Tightly scoped permissions to just 's3:GetObject' # instead of 's3:*' or '*' Action : s3:GetObject Resource : \"arn:aws:s3:::my-bucket/*\" functions : hello : handler : handler.hello Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 resource \"aws_iam_role\" \"this\" { name = \"my-function-role\" assume_role_policy = data.aws_iam_policy_document.assume.json inline_policy { name = \"FunctionPolicy\" policy = data.aws_iam_policy_document.this.json } } data \"aws_iam_policy_document\" \"assume\" { statement { actions = [ \"sts:AssumeRole\" ] principals { type = \"Service\" identifiers = [ \"lambda.amazonaws.com\" ] } } } data \"aws_iam_policy_document\" \"this\" { statement { # Tightly scoped permissions to just 'dynamodb:Query' # instead of 'dynamodb:*' or '*' actions = [ \"dynamodb:Query\" ] resources = [ \"arn:aws:dynamodb:eu-west-1:111122223333:table/my-table\" ] } } resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" handler = \"main.handler\" runtime = \"python3.8\" filename = \"function.zip\" role = aws_iam_role.this.arn }","title":"Implementations"},{"location":"rules/lambda/star_permissions/#see-also","text":"Serverless Lens: Identity and Access Management AWS Lambda execution role","title":"See also"},{"location":"rules/lambda/tracing/","text":"Lambda Tracing \u00b6 Level : Warning Initial version : 0.1.3 cfn-lint : WS1000 tflint : aws_lambda_function_tracing_rule AWS Lambda can emit traces to AWS X-Ray, which enables visualizing service maps for faster troubleshooting. Why is this a warning? \u00b6 You might use third party solutions for monitoring serverless applications. If this is the case, enabling tracing for your AWS Lambda functions might be optional. Refer to the documentation of your monitoring solutions to see if you should enable AWS X-Ray tracing or not. Implementations \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { Code , Function , Runtime , Tracing } from '@aws-cdk/aws-lambda' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , // Enable active tracing tracing : Tracing.ACTIVE , } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"Resources\" : { \"MyFunction\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { // Required proper t ies \"CodeUri\" : \".\" , \"Runtime\" : \"python3.8\" , \"Handler\" : \"main.handler\" , // E na ble ac t ive tra ci n g \"Tracing\" : \"Active\" } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 Resources : MyFunction : Type : AWS::Serverless::Function Properties : # Required properties CodeUri : . Runtime : python3.8 Handler : main.handler # Enable active tracing Tracing : Active Serverless Framework 1 2 3 4 5 6 7 8 provider : tracing : # Enable active tracing for Lambda functions lambda : true functions : hello : handler : handler.hello Terraform 1 2 3 4 5 6 7 8 9 10 11 resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" runtime = \"python3.8\" handler = \"main.handler\" filename = \"function.zip\" # Enable active tracing tracing_config { mode = \"Active\" } } See also \u00b6 Serverless Lens: Distributed Tracing Using AWS Lambda with X-Ray","title":"Lambda Tracing"},{"location":"rules/lambda/tracing/#lambda-tracing","text":"Level : Warning Initial version : 0.1.3 cfn-lint : WS1000 tflint : aws_lambda_function_tracing_rule AWS Lambda can emit traces to AWS X-Ray, which enables visualizing service maps for faster troubleshooting.","title":"Lambda Tracing"},{"location":"rules/lambda/tracing/#why-is-this-a-warning","text":"You might use third party solutions for monitoring serverless applications. If this is the case, enabling tracing for your AWS Lambda functions might be optional. Refer to the documentation of your monitoring solutions to see if you should enable AWS X-Ray tracing or not.","title":"Why is this a warning?"},{"location":"rules/lambda/tracing/#implementations","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { Code , Function , Runtime , Tracing } from '@aws-cdk/aws-lambda' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); const myFunction = new Function ( scope , 'MyFunction' , { code : Code.fromAsset ( 'src/hello/' ), handler : 'main.handler' , runtime : Runtime.PYTHON_3_8 , // Enable active tracing tracing : Tracing.ACTIVE , } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"Resources\" : { \"MyFunction\" : { \"Type\" : \"AWS::Serverless::Function\" , \"Properties\" : { // Required proper t ies \"CodeUri\" : \".\" , \"Runtime\" : \"python3.8\" , \"Handler\" : \"main.handler\" , // E na ble ac t ive tra ci n g \"Tracing\" : \"Active\" } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 Resources : MyFunction : Type : AWS::Serverless::Function Properties : # Required properties CodeUri : . Runtime : python3.8 Handler : main.handler # Enable active tracing Tracing : Active Serverless Framework 1 2 3 4 5 6 7 8 provider : tracing : # Enable active tracing for Lambda functions lambda : true functions : hello : handler : handler.hello Terraform 1 2 3 4 5 6 7 8 9 10 11 resource \"aws_lambda_function\" \"this\" { function_name = \"my-function\" runtime = \"python3.8\" handler = \"main.handler\" filename = \"function.zip\" # Enable active tracing tracing_config { mode = \"Active\" } }","title":"Implementations"},{"location":"rules/lambda/tracing/#see-also","text":"Serverless Lens: Distributed Tracing Using AWS Lambda with X-Ray","title":"See also"},{"location":"rules/sns/redrive_policy/","text":"SNS Redrive Policy \u00b6 Level : Error Initial version : 0.1.7 cfn-lint : ES7000 tflint : aws_sns_topic_subscription_redrive_policy You can configure the redrive policy on an Amazon SNS subscription. If SNS cannot deliver the message after the number of attempts set in its delivery policy, SNS will send it to the dead-letter queue specified in the redrive policy. Implementations \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import { Queue } from '@aws-cdk/aws-sqs' ; import { Topic } from '@aws-cdk/aws-sns' ; import { UrlSubscription } from '@aws-cdk-aws-sns-subscriptions' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); // Dead letter queue const myDLQ = new Queue ( scope , 'MyDLQ' , ); // SNS Topic const myTopic = new Topic ( scope , 'MyTopic' ); // Adding an URL subscription myTopic . addSubscription ( new UrlSubscription ( 'https://example.com' , { // Configure the redrive policy for the subscription deadLetterQueue : myDLQ , } )); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"Resources\" : { \"MySubscription\" : { \"Type\" : \"AWS::SNS::Subscription\" , \"Properties\" : { \"Protocol\" : \"https\" , \"Endpoint\" : \"https://example.com/\" \"TopicArn\" : \"my-topic-arn\" , // Co nf igure t he redrive policy f or t he subscrip t io n \"RedrivePolicy\" : \"{ \\\"deadLetterTargetArn\\\": \\\"arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue\\\"}\" } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 Resources : MySubscription : Type : AWS::SNS::Subscription Properties : Protocol : https Endpoint : https://example.com/ TopicArn : \"my-topic-arn\" # Configure the redrive policy for the subscription RedrivePolicy : | { \"deadLetterTargetArn\": \"arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue\" } Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # For subscriptions to Lambda function endpoints functions : MyFunction : handler : hello.handler events : - sns : topicName : my-topic # Configure the redrive policy for the subscription to the Lambda function redrivePolicy : deadLetterTargetArn : arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue # For subscriptions to other types of endpoint resources : Resources : MySubscription : Type : AWS::SNS::Subscription Properties : Protocol : https Endpoint : https://example.com/ TopicArn : \"my-topic-arn\" # Configure the redrive policy for the subscription to another type of resource RedrivePolicy : | { \"deadLetterTargetArn\": \"arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue\" } Terraform 1 2 3 4 5 6 7 8 9 10 11 12 resource \"aws_sns_topic_subscription\" \"this\" { endpoint = \"https://example.com/\" protocol = \"https\" topic_arn = \"my-topic-arn\" # Configure the redrive policy for the subscription redrive_policy = << EOF { \"deadLetterTargetArn\" : \"arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue\" } EOF } See also \u00b6 Amazon SNS message delivery retries Amazon SNS dead-letter queues (DLQs) CloudFormation : AWS::SNS::Subscription Terraform : aws_sns_topic_subscription","title":"SNS Redrive Policy"},{"location":"rules/sns/redrive_policy/#sns-redrive-policy","text":"Level : Error Initial version : 0.1.7 cfn-lint : ES7000 tflint : aws_sns_topic_subscription_redrive_policy You can configure the redrive policy on an Amazon SNS subscription. If SNS cannot deliver the message after the number of attempts set in its delivery policy, SNS will send it to the dead-letter queue specified in the redrive policy.","title":"SNS Redrive Policy"},{"location":"rules/sns/redrive_policy/#implementations","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import { Queue } from '@aws-cdk/aws-sqs' ; import { Topic } from '@aws-cdk/aws-sns' ; import { UrlSubscription } from '@aws-cdk-aws-sns-subscriptions' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); // Dead letter queue const myDLQ = new Queue ( scope , 'MyDLQ' , ); // SNS Topic const myTopic = new Topic ( scope , 'MyTopic' ); // Adding an URL subscription myTopic . addSubscription ( new UrlSubscription ( 'https://example.com' , { // Configure the redrive policy for the subscription deadLetterQueue : myDLQ , } )); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"Resources\" : { \"MySubscription\" : { \"Type\" : \"AWS::SNS::Subscription\" , \"Properties\" : { \"Protocol\" : \"https\" , \"Endpoint\" : \"https://example.com/\" \"TopicArn\" : \"my-topic-arn\" , // Co nf igure t he redrive policy f or t he subscrip t io n \"RedrivePolicy\" : \"{ \\\"deadLetterTargetArn\\\": \\\"arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue\\\"}\" } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 11 12 13 Resources : MySubscription : Type : AWS::SNS::Subscription Properties : Protocol : https Endpoint : https://example.com/ TopicArn : \"my-topic-arn\" # Configure the redrive policy for the subscription RedrivePolicy : | { \"deadLetterTargetArn\": \"arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue\" } Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # For subscriptions to Lambda function endpoints functions : MyFunction : handler : hello.handler events : - sns : topicName : my-topic # Configure the redrive policy for the subscription to the Lambda function redrivePolicy : deadLetterTargetArn : arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue # For subscriptions to other types of endpoint resources : Resources : MySubscription : Type : AWS::SNS::Subscription Properties : Protocol : https Endpoint : https://example.com/ TopicArn : \"my-topic-arn\" # Configure the redrive policy for the subscription to another type of resource RedrivePolicy : | { \"deadLetterTargetArn\": \"arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue\" } Terraform 1 2 3 4 5 6 7 8 9 10 11 12 resource \"aws_sns_topic_subscription\" \"this\" { endpoint = \"https://example.com/\" protocol = \"https\" topic_arn = \"my-topic-arn\" # Configure the redrive policy for the subscription redrive_policy = << EOF { \"deadLetterTargetArn\" : \"arn:aws:sqs:us-east-2:123456789012:MyDeadLetterQueue\" } EOF }","title":"Implementations"},{"location":"rules/sns/redrive_policy/#see-also","text":"Amazon SNS message delivery retries Amazon SNS dead-letter queues (DLQs) CloudFormation : AWS::SNS::Subscription Terraform : aws_sns_topic_subscription","title":"See also"},{"location":"rules/sqs/redrive_policy/","text":"SQS Redrive Policy \u00b6 Level : Error Initial version : 0.1.7 cfn-lint : ES6000 tflint : aws_sqs_queue_redrive_policy You can configure the redrive policy on an Amazon SQS queue. With a redrive policy, you can define how many times SQS will make the messages available for consumers. After that, SQS will send it to the dead-letter queue specified in the policy. Implementations \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { Queue } from '@aws-cdk/aws-sqs' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); // Dead letter queue const myDLQ = new Queue ( scope , \"MyDLQ\" , ); const myQueue = new Queue ( scope , \"MyQueue\" , { // Configure the redrive policy for MyQueue deadLetterQueue : { maxReceiveCount : 4 , queue : myDLQ , }, } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 { \"Resources\" : { \"MyQueue\" : { \"Type\" : \"AWS::SQS::Queue\" , \"Properties\" : { // Co nf igure t he redrive policy f or MyQueue \"RedrivePolicy\" : \"{ \\\"deadLetterTargetArn\\\": \\\"arn:aws:sqs:us-east-2:111122224444:my-dlq\\\", \\\"maxReceiveCount\\\": 4 }\" } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 Resources : MyQueue : Type : AWS::SQS::Queue Properties : # Configure the redrive policy for MyQueue RedrivePolicy : | { \"deadLetterTargetArn\": \"arn:aws:sqs:us-east-2:111122224444:my-dlq\", \"maxReceiveCount\": 4 } Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 resources : Resources : MyQueue : Type : AWS::SQS::Queue Properties : # Configure the redrive policy for MyQueue RedrivePolicy : | { \"deadLetterTargetArn\": \"arn:aws:sqs:us-east-2:111122224444:my-dlq\", \"maxReceiveCount\": 4 } Terraform 1 2 3 4 5 6 7 resource \"aws_sqs_queue\" \"this\" { # Configure the redrive policy for the queue redrive_policy = jsonencode ({ deadLetterTargetArn = \"arn:aws:sqs:us-east-2:111122224444:my-dlq\" maxReceiveCount = 4 }) } See also \u00b6 Serverless Lens: Failure Management Amazon SQS dead-letter-queues CloudFormation : AWS::SQS::Queue Terraform : aws_sqs_queue","title":"SQS Redrive Policy"},{"location":"rules/sqs/redrive_policy/#sqs-redrive-policy","text":"Level : Error Initial version : 0.1.7 cfn-lint : ES6000 tflint : aws_sqs_queue_redrive_policy You can configure the redrive policy on an Amazon SQS queue. With a redrive policy, you can define how many times SQS will make the messages available for consumers. After that, SQS will send it to the dead-letter queue specified in the policy.","title":"SQS Redrive Policy"},{"location":"rules/sqs/redrive_policy/#implementations","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { Queue } from '@aws-cdk/aws-sqs' ; export class MyStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); // Dead letter queue const myDLQ = new Queue ( scope , \"MyDLQ\" , ); const myQueue = new Queue ( scope , \"MyQueue\" , { // Configure the redrive policy for MyQueue deadLetterQueue : { maxReceiveCount : 4 , queue : myDLQ , }, } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 { \"Resources\" : { \"MyQueue\" : { \"Type\" : \"AWS::SQS::Queue\" , \"Properties\" : { // Co nf igure t he redrive policy f or MyQueue \"RedrivePolicy\" : \"{ \\\"deadLetterTargetArn\\\": \\\"arn:aws:sqs:us-east-2:111122224444:my-dlq\\\", \\\"maxReceiveCount\\\": 4 }\" } } } } CloudFormation (YAML) 1 2 3 4 5 6 7 8 9 10 Resources : MyQueue : Type : AWS::SQS::Queue Properties : # Configure the redrive policy for MyQueue RedrivePolicy : | { \"deadLetterTargetArn\": \"arn:aws:sqs:us-east-2:111122224444:my-dlq\", \"maxReceiveCount\": 4 } Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 resources : Resources : MyQueue : Type : AWS::SQS::Queue Properties : # Configure the redrive policy for MyQueue RedrivePolicy : | { \"deadLetterTargetArn\": \"arn:aws:sqs:us-east-2:111122224444:my-dlq\", \"maxReceiveCount\": 4 } Terraform 1 2 3 4 5 6 7 resource \"aws_sqs_queue\" \"this\" { # Configure the redrive policy for the queue redrive_policy = jsonencode ({ deadLetterTargetArn = \"arn:aws:sqs:us-east-2:111122224444:my-dlq\" maxReceiveCount = 4 }) }","title":"Implementations"},{"location":"rules/sqs/redrive_policy/#see-also","text":"Serverless Lens: Failure Management Amazon SQS dead-letter-queues CloudFormation : AWS::SQS::Queue Terraform : aws_sqs_queue","title":"See also"},{"location":"rules/step_functions/tracing/","text":"Step Functions Tracing \u00b6 Level : Warning Initial version : 0.1.3 cfn-lint : WS5000 tflint : aws_sfn_state_machine_tracing AWS Step Functions can emit traces to AWS X-Ray, which enables visualizing service maps for faster troubleshooting. Why is this a warning? \u00b6 You might use third party solutions for monitoring serverless applications. If this is the case, enabling tracing for Step Functions might be optional. Refer to the documentation of your monitoring solutions to see if you should enable AWS X-Ray tracing or not. Implementations \u00b6 CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import { Function } from '@aws-cdk/aws-lambda' ; import { StateMachine } from '@aws-cdk/aws-stepfunctions' ; import * as tasks from '@aws-cdk/aws-stepfunctions- export class MyStack extends cdk.Stack { constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); const myFunction = new Function( scope, ' MyFunction ', { code: Code.fromAsset(' src / hello / '), handler: ' main . handler ', runtime: Runtime.PYTHON_3_8, } ); const myJob = tasks.LambdaInvoke( scope, ' MyJob ', { lambdaFunction: myFunction, }, ); const myStateMachine = new StateMachine( scope, ' MyStateMachine ' , { definition : myJob , // Enable tracing on Step Functions tracingEnabled : true , } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"Resources\" : { \"StateMachine\" : { \"Type\" : \"AWS::StepFunctions::StateMachine\" , \"Properties\" : { \"DefinitionString\" : \"{ \\\"StartAt\\\": \\\"HelloWorld\\\", \\\"States\\\": { \\\"HelloWorld\\\": { \\\"Type\\\": \\\"Task\\\", \\\"Resource\\\": \\\"arn:aws:lambda:us-east-1:111122223333:function:HelloFunction\\\", \\\"End\\\": \\\"true\\\" }}}\" , \"RoleArn\" : \"arn:aws:iam::111122223333:role/service-role/StatesExecutionRole\" , // E na ble ac t ive tra ci n g f or S te p Fu n c t io ns \"TracingConfiguration\" : { \"Enabled\" : true } } } } } CloudFormation YAML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Resources : StateMachine : Type : AWS::StepFunctions::StateMachine Properties : DefinitionString : | { \"StartAt\": \"HelloWorld\", \"States\": { \"HelloWorld\": { \"Type\": \"Task\", \"Resource\": \"arn:aws:lambda:us-east-1:111122223333:function:HelloFunction\", \"End\": \"true\" } } } RoleArn : arn:aws:iam::111122223333:role/service-role/StatesExecutionRole # Enable active tracing for Step Functions TracingConfiguration : Enabled : true Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 resources : Resources : StateMachine : Type : AWS::StepFunctions::StateMachine Properties : DefinitionString : | { \"StartAt\": \"HelloWorld\", \"States\": { \"HelloWorld\": { \"Type\": \"Task\", \"Resource\": \"arn:aws:lambda:us-east-1:111122223333:function:HelloFunction\", \"End\": \"true\" } } } RoleArn : arn:aws:iam::111122223333:role/service-role/StatesExecutionRole # Enable active tracing for Step Functions TracingConfiguration : Enabled : true Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 resource \"aws_sfn_state_machine\" \"this\" { name = \"my-state-machine\" role_arn = \"arn:aws:iam::111122223333:role/my-state-machine-role\" definition = << EOF { \"StartAt\" : \"HelloWorld\" , \"States\" : { \"HelloWorld\" : { \"Type\" : \"Task\" , \"Resource\" : \"arn:aws:lambda:us-east-1:111122223333:function:HelloFunction\" , \"End\" : \"true\" } } } EOF # Enable active tracing for Step Functions tracing_configuration { enabled = true } } See also \u00b6 Serverless Lens: Distributed Tracing AWS X-Ray and Step Functions","title":"Step Functions Tracing"},{"location":"rules/step_functions/tracing/#step-functions-tracing","text":"Level : Warning Initial version : 0.1.3 cfn-lint : WS5000 tflint : aws_sfn_state_machine_tracing AWS Step Functions can emit traces to AWS X-Ray, which enables visualizing service maps for faster troubleshooting.","title":"Step Functions Tracing"},{"location":"rules/step_functions/tracing/#why-is-this-a-warning","text":"You might use third party solutions for monitoring serverless applications. If this is the case, enabling tracing for Step Functions might be optional. Refer to the documentation of your monitoring solutions to see if you should enable AWS X-Ray tracing or not.","title":"Why is this a warning?"},{"location":"rules/step_functions/tracing/#implementations","text":"CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import { Function } from '@aws-cdk/aws-lambda' ; import { StateMachine } from '@aws-cdk/aws-stepfunctions' ; import * as tasks from '@aws-cdk/aws-stepfunctions- export class MyStack extends cdk.Stack { constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); const myFunction = new Function( scope, ' MyFunction ', { code: Code.fromAsset(' src / hello / '), handler: ' main . handler ', runtime: Runtime.PYTHON_3_8, } ); const myJob = tasks.LambdaInvoke( scope, ' MyJob ', { lambdaFunction: myFunction, }, ); const myStateMachine = new StateMachine( scope, ' MyStateMachine ' , { definition : myJob , // Enable tracing on Step Functions tracingEnabled : true , } ); } } CloudFormation (JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"Resources\" : { \"StateMachine\" : { \"Type\" : \"AWS::StepFunctions::StateMachine\" , \"Properties\" : { \"DefinitionString\" : \"{ \\\"StartAt\\\": \\\"HelloWorld\\\", \\\"States\\\": { \\\"HelloWorld\\\": { \\\"Type\\\": \\\"Task\\\", \\\"Resource\\\": \\\"arn:aws:lambda:us-east-1:111122223333:function:HelloFunction\\\", \\\"End\\\": \\\"true\\\" }}}\" , \"RoleArn\" : \"arn:aws:iam::111122223333:role/service-role/StatesExecutionRole\" , // E na ble ac t ive tra ci n g f or S te p Fu n c t io ns \"TracingConfiguration\" : { \"Enabled\" : true } } } } } CloudFormation YAML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Resources : StateMachine : Type : AWS::StepFunctions::StateMachine Properties : DefinitionString : | { \"StartAt\": \"HelloWorld\", \"States\": { \"HelloWorld\": { \"Type\": \"Task\", \"Resource\": \"arn:aws:lambda:us-east-1:111122223333:function:HelloFunction\", \"End\": \"true\" } } } RoleArn : arn:aws:iam::111122223333:role/service-role/StatesExecutionRole # Enable active tracing for Step Functions TracingConfiguration : Enabled : true Serverless Framework 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 resources : Resources : StateMachine : Type : AWS::StepFunctions::StateMachine Properties : DefinitionString : | { \"StartAt\": \"HelloWorld\", \"States\": { \"HelloWorld\": { \"Type\": \"Task\", \"Resource\": \"arn:aws:lambda:us-east-1:111122223333:function:HelloFunction\", \"End\": \"true\" } } } RoleArn : arn:aws:iam::111122223333:role/service-role/StatesExecutionRole # Enable active tracing for Step Functions TracingConfiguration : Enabled : true Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 resource \"aws_sfn_state_machine\" \"this\" { name = \"my-state-machine\" role_arn = \"arn:aws:iam::111122223333:role/my-state-machine-role\" definition = << EOF { \"StartAt\" : \"HelloWorld\" , \"States\" : { \"HelloWorld\" : { \"Type\" : \"Task\" , \"Resource\" : \"arn:aws:lambda:us-east-1:111122223333:function:HelloFunction\" , \"End\" : \"true\" } } } EOF # Enable active tracing for Step Functions tracing_configuration { enabled = true } }","title":"Implementations"},{"location":"rules/step_functions/tracing/#see-also","text":"Serverless Lens: Distributed Tracing AWS X-Ray and Step Functions","title":"See also"}]}